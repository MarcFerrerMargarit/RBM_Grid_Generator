\documentclass[12pt,a4paper,openright,oneside]{article}
\usepackage{amsfonts, amsmath, amssymb,latexsym,amsthm, mathrsfs, enumerate}
\usepackage[catalan]{babel}
\usepackage{epsfig}
\usepackage{tikz}
\parskip=5pt
\parindent=15pt
\usepackage[margin=1.2in]{geometry}
\usepackage{graphicx}
\graphicspath{{./Images/}}
\usepackage{listings}
\usepackage[latin1]{inputenc}
\usepackage{algorithm}
\usepackage{algorithmic}

\setcounter{page}{0}

\numberwithin{equation}{section}
\newtheorem{teo}{Teorema}[subsubsection]
\newtheorem*{teo*}{Teorema}
\newtheorem*{prop*}{Proposici�}
\newtheorem*{corol*}{Corol�lari}
\newtheorem{prop}{Proposici�}[subsubsection]
\newtheorem{corol}{Corol�lari}[subsubsection]
\newtheorem{lema}{Lema}[subsubsection]
\newtheorem{defi}{Definici�}[subsubsection]
\newtheorem{nota}{Notaci�}

\theoremstyle{definition}
\newtheorem{prob}{Problema}
\newtheorem*{sol}{Soluci�}
\newtheorem{ex}{Exemple}
\newtheorem{exs}{Exemples}
\newtheorem{obs}{Observaci�}
\newtheorem{obss}{Observacions}

\def\qed{\hfill $\square$}

\renewcommand{\refname}{Bibliografia}
% --------------------------------------------------
\usepackage{fancyhdr}

\lhead{}
\lfoot{}
\rhead{}
\cfoot{}
\rfoot{\thepage}

\begin{document}

\bibstyle{plain}

\thispagestyle{empty}

\begin{titlepage}
\begin{center}
\begin{figure}[htb]
\begin{center}
\includegraphics[width=6cm]{ub_color.pdf}
\end{center}
\end{figure}

\textbf{\LARGE Treball final de grau} \\
\vspace*{.5cm}
\textbf{\LARGE GRAU EN INFORM�TICA } \\
\vspace*{.5cm}
\textbf{\LARGE Facultat de Matem\`atiques i Inform\`atica \\ Universitat de Barcelona} \\
\vspace*{1.5cm}
\rule{16cm}{0.1mm}\\
\begin{Huge}
\textbf{MACHINE LEARNING APLICAT A  LA GENERACI� DE MOODBOARDS} \\
\end{Huge}
\rule{16cm}{0.1mm}\\

\vspace{1cm}

\begin{center}
\textbf{\LARGE Autor: Ferrer Margarit, Marc}

\vspace*{2cm}

\renewcommand{\arraystretch}{1.5}
\begin{tabular}{ll}
\textbf{\Large Director:} & \textbf{\Large David Buchaca } \\
\textbf{\Large Realitzat a:} & \textbf{\Large  Interiorvista   } \\
 & \textbf{\Large} \\
\textbf{\Large Barcelona,} & \textbf{\Large 25 de juny de 2018 }
\end{tabular}

\end{center}

\end{center}

\end{titlepage}


\newpage
\pagenumbering{roman} 

\section*{Abstract}

Moodboards are used to represent objects that are formed by the composition of other objects and they try to obtain a result of cohesion among them and try to generate a new image.
Machine learning allows us to train a machine so that it can generate the values with the data that we have entered previously, which must be correct data.
\\\
What we want to obtain is a combination between the two parts to achieve the generation of new images, with correct and cohesive objects and different from the images used to train the machine.
\\\
So the objective of this project is to create a machine that allows us to create, from data, moodboards, generate correct it without the need of a person to create them, and design an automated system to replace a slow task and replace this task.
\\\
Apart from creating this system, we will also analyze its efficiency, with respect to the non-automated system and if the generation of these moodboards is correct, so we can establish whether the system created is efficient enough, fast and accurate generating moodboards.
\\\
Finally, these tests will be carried out by supervising expert people in order to improve the evaluation.

\section*{Resum}
Actualment els moodboards s'utilitzen per representar objectes que estan formats per la composici� d'altres objectes i pretenen obtenir un resultat de cohesi� entre ells i generar una imatge nova.
El machine learning ens permet entrenar una m�quina per tal que aquesta sigui capa� de generar els valors amb les dades que li hem entrat pr�viament, les quals han de ser dades correctes.
\\\
El que volem obtenir �s una combinaci� entre les dues parts per aconseguir la generaci� de noves imatges, amb objectes totalment correctes i cohesionats i diferents de les imatges utilitzades per entrenar la m�quina.
\\\
Aix� doncs l'objectiu d'aquest projecte �s crear una m�quina que ens permeti crear, a partir de dades correctes, moodboards, generar moodboards correctes sense la necessitat que una persona els hagi de crear, dissenyar un sistema automatitzat per a reempla�ar una tasca lenta i mec�nica que realitzen a m� v�ries persones.
\\\
A part de crear aquest sistema, tamb� s'analitzar� la seva efici�ncia, respecte al sistema no automatitzat i si la generaci� d'aquests moodboards �s correcte, aix� podrem establir si el sistema creat �s prou efica�, r�pid i prec�s a l'hora de generar, en aquest cas, moodboards.
\\\
Finalment, aquestes proves es realitzaran mitjan�ant la supervisi� de persones expertes per a tal de millorar l'avaluaci�. 
\newpage 


\section*{Agra�ments}

Vull agrair a la empresa InteriorVista per donar-me l'oportunitat de realitzar aquest projecte i per tal de facilitar-me totes les eines i recursos necessaris per tal de poder desenvolupar i acabar el projecte.\\\
Tamb� vull agrair al meu tutor a l'empresa, David Osuna, per proposar-me aquest projecte tant important i tant interessant per a realitzar i per ajudar-me en tots els dubtes que he tingut durant aquest temps.\\\
I finalment vull agrair al meu tutor del treball, David Buchaca, per haver-me ajudat  a organitzar el projecte i per haver-me ajudat a trobar eines i solucions per tal de resoldre els problemes que se'm presentaven al llarg del desenvolupament.
\newpage

\tableofcontents

\newpage

\pagenumbering{arabic} 
\setcounter{page}{1}
\section{Introducci� i objectius}

Avui en dia, tot i que depenem de les m�quines i dels programes per a realitzar tasques que poden ser pesades i lentes encara en queden moltes que es realitzen a m�. Moltes d'aquestes tasques en algun moment podrien ser automatitzades per tal que es puguin realitzar m�s r�pidament de forma menys pesada i probablement m�s precisa.
\\\\
Aquest projecte vol aconseguir que una tasca que actualment costa temps, dedicaci� i concentraci� es transformi en una tasca menys tediosa  i m�s rapida de realitzar. L'objectiu del sistema que proposem  �s reduir el temps que un disenyador triga a fer la tasca que volem optimitzar. %Aquesta millora que volem aconseguir, s'ha de realitzar partint de la tasca original i d'un conjunt de solucioncs de la tasca que el nostre programa usar� per ``apendre''.
\\\\
Aquesta tasca consisteix en la generaci� de moodboards. %Pero... \textbf{Qu� �s un moodboard?}\\\
Un moodboard �s una combinaci� d'imatges relacionades entre elles que juntes formen una sola imatge. Normalment  els moodboards es fan servir per descriure combinacions de elements per a generar imatges de paisatges, d'aplicacions, decoraci� i creaci� d'habitacions etc... \\\\
El treball proposa facilicar la tasca de la generaci� de moodboards. Actualment per generar moodboards es necessita fer una cerca de totes les imatges que es desitgen col�locar. Un cop triades s'han de col�locar de forma que formin un sol conjunt i anar-les editant per tal de generar una sola imatge. \\\
Aquest proc�s pot ser molt lent i tedi�s, ja que buscar totes les imatges necess�ries costa temps. A m�s cal col�locar les imatges correctament i editar-les per tal que totes s'ajuntin i formin una sola imatge, cosa que encara augmenta m�s el tems total de generar un moodboard. \\\
Aquest proc�s s'ha de millorar  per un altre de m�s r�pid conservant alguns aspectes. L'objectiu final �s que tot sigui m�s mec�nic i m�s r�pid. \\\\
Com hem dit anteriorment poden haver-hi moodboards de molts tipus, per� per aquest projecte ens centrarem amb els moodboards d'interiorisme, �s a dir, els que defineixen una estan�a d'una casa, un dormitori, un bany, una cuina, etc.  Una de les dificultats de definir  una estan�a recau en triar elements que defineixin un estil de manera que el conjunt de elements de una estan�a tingui ``sentit'' i el conjunt sigui agradable per les persones. Nosaltres suposarem que cada moodboard pertanyer� a un estil determinat. %Aix�, cada moodboard ser� una combinaci� de mobles i objectes que junts representaran l'estil i descriuran una zona de una casa.
\\\\
El treball proposa facilicar la tasca de la generaci� de moodboards. Actualment per generar moodboards es necessita fer una cerca de totes les imatges que es desitgen col�locar a internet. Un cop triades les imatges s'han de col�locar de forma que formin un sol conjunt i anar-les editant per tal de generar una sola imatge.  Aquest proc�s pot ser molt lent i tedi�s, ja que buscar totes les imatges necess�ries costa temps. A m�s cal col�locar les imatges correctament i editar-les (retallant i enganxant desde programes de edici� de imatges) per tal que totes s'ajuntin i formin una sola imatge.  \\\\
Per a millorar la velocitat de generaci� de moodboards el treball es centra en dos aspectes:
\begin{itemize}
\item Crear una aplicaci� en unity, conectada a una base de dades, que permeti als disenyadors buscar els items rapidament en una interficie gr�fica i arrastrarlos a una graella que determinara la moodboard. Aquesta aplicaci� ha de permetre buscar items amb caracteristiques concretes com color de un objecte, que poden ser molt importants per a definir espais agradables.
\item Usar un algorisme de machine learning per tal de generar noves moodboards a partir d'un conjunt de moodboards previament fet per disenyadors. En cas que la qualitat de la generaci� no pugui competir amb la de un disenyador aquest algorisme podria ser interessant per a generar una moodboard inicial desde la qual els disenyadors poguessin comen�ar a treballar.
\end{itemize}

%Aquest proc�s s'ha de millorar  per un altre de m�s r�pid conservant alguns aspectes. L'objectiu final �s que tot sigui m�s mec�nic i m�s r�pid. \\\\
%Com hem dit anteriorment poden haver-hi moodboards de molts tipus, per� per aquest projecte ens centrarem amb els moodboards d'interiorisme, �s a dir, els que defineixen una estan�a d'una casa, un dormitori, un bany, una cuina, etc.  Una de les dificultats de definir  una estan�a recau en triar elements que defineixin un estil de manera que el conjunt de elements de una estan�a tingui ``sentit'' i el conjunt sigui agradable per les persones. Nosaltres suposarem que cada moodboard pertanyer� a un estil determinat. %Aix�, cada moodboard ser� una combinaci� de mobles i objectes que junts representaran l'estil i descriuran una zona de una casa.
%Un cop explicat tota la base de la qual partirem l'objectiu que ens proposem �s crear un sistema automatitzat que ens permeti la generaci� autom�tica de moodboards,

\newpage
\subsection*{Hip�tesi}

{\bf L'objectiu del treball �s validar si �s possible incrementar la eficiencia dels disenyadors de moodboards amb una eina creada adhoc per a ells. En particular, voldriem validar si es posible crear un algorisme que faciliti la generaci� de moodboards usant Restricted Boltzmann Machines (RBM) per tal de donar una configuraci� inicial de items amb la que treballar. }
\\\\
Per tal de poder crear aquest sistema utilitzarem t�cniques de machine learning per tal de crear una m�quina capa� d'aprendre i de generar a partir de les dades que ha apr�s. D'aquesta forma podem estructurar el projecte en dues parts essencials. La primera part descriur�  la generaci� de moodboards mitjan�ant una interficia grafica. La segona  part descriur� la creaci� d'una m�quina capa� de llegir els moodboards creats anteriorment i apendre a crearne de nous. 
\\\\
Usarem les  RBMs per a generar configuracions de moodboards de manera que un interiorista pugui comen�ar a treballar desde un moodboard ``que tingui sentit'', sense necessitat de comen�ar desde zero. Poder fer aix� tindria un gran impacte en reduir el temps de cerca dels mobles i objectes necessaris que es necessiten per a cada zona d'una casa, obtenint  moodboards d'una forma r�pida i eficient que tot i potser no tingui la qualitat per substituir el treball d'un interiorista pugui ser de prou qualitat com per a donar ja una bona feina feta.
\\\\
Com ja hem mencionat, farem servir t�cniques de machine learning, �s a dir algorismes d'aprenentatge autom�tic. 
L'aprenentatge autom�tic �s un camp de la intel�lig�ncia artificial que est� dedicat al disseny, l'an�lisi i el desenvolupament d'algorismes i t�cniques que permeten que les m�quines aprenguin a fer tasques a partir de dades. Es tracta de crear programes capa�os de generalitzar comportaments a partir del reconeixement de patrons.  D'aquesta manera nosaltres el que volem fer �s una m�quina que sigui capa� de apendre de les moodboards que li donarem per despr�s poder generar  noves dades. Un dels possibles problemes que es poden trobar al usar aquest tipus de m�quines �s que necessiten moltes dades per poder-se entrenar.\\\\
Finalment, tot i que l'objectiu �s crear un sistema automatitzat per a millorar la realitzaci� de la tasca de generaci� de moodbards tamb� considerarem crucial analitzar com �s de millor aquest sistema respecte de l'anterior. Per tal de saber-ho, al final de tot el projecte avaluarem el sistema mitjan�ant l'ajuda humana, en aquest cas, persones expertes que han generat molts de moodboards i que tamb� han generat els correctes per entrenar la m�quina i d'aquesta forma podrem validar les qualitats del sistema mitjan�ant diverses proves que s'explicaran m�s endavant.
\\\
\newpage
\subsection*{Estructura de la Mem�ria}
En primer lloc ens centrarem com generem els moodboards, amb quines eines i alguns exemples per tal de crear-los. Aquests moodboards seran els que posteriorment serviran per entrenar la m�quina. Tamb� explicarem el funcionament de les eines i les diferencies amb el m�tode ``tradicional".\\\\
Seguidament explicarem quin tipus de m�quina farem servir, �s a dir, el tipus d'algorisme d'aprenentatge autom�tic  aplicarem, els motius pels quals hem decidit escollir aquest algorisme i quines s�n les seves propietats b�siques.\\\\
Despr�s analitzarem com s�n les dades d'entrada, com a partir del moodboards generats obtenim, com transformem aquestes imatges per tal d'obtenir dades v�lides per a entrenar la m�quina. Tamb� definirem com han de ser aquestes dades i com han de ser les dades que volem obtenir de sortida i com les transformarem en imatges de nou. \\\\
Per motius de confidencialitat la empresa no ha deixat publicar ni adjuntar el codi en aquesta mem�ria. De totes maneres, s'han incl�s parts de codi on es pot veure com s'han entrenat els models i els pre-processos necessaris per a generar els inputs. \\\\
Finalment, analitzarem els resultats obtinguts i els avaluarem mitjan�ant diferents proves que realitzarem per comprovar la seva efici�ncia i els resultats envers els moodboards creats pr�viament per experts.
\newpage

\section{Moodboards}

Abans de comen�ar a explicar les dades, el funcionament de l'algorisme i els resultats ens hem de centrar en la primera part del projecte i una de les m�s importants, la generaci� de dades.\\\
Com hem comentat a la introducci� les nostres dades s�n moodboards que defineixen diferents estances d'un habitatge d'un estil concret. \\\
A continuaci� explicarem com s�n els moodboards, �s a dir, com estan formats els moodboards actuals i com seran els nostres moodboards que generarem amb la nostra eina. Tamb� explicarem com est� dissenyada la nostra eina, amb quines eines de programaci� s'ha realitzat i com es creen moodboards seguin l'est�ndard que hem decidit.
\subsection{Disseny dels moodboards}

Com b� ja hem explicat un moodboard �s una combinaci� d'imatges relacionades entre elles que juntes formen una sola imatge. Aquesta imatge que formen �s una imatge ben generada, �s a dir, que hi ha cohesi� amb tots els elements de forma que sembli una fotografia mentre que es tracta una composici� de diferents objectes editats manualment mitjan�ant eines d'edici� d'imatge per formar una sola imatge coherent i compacta, la qual mostrar� una habitaci� d'una casa.\\\\
Realitzar moodboards amb aquesta t�cnica t� avantatges i inconvenients. Un dels problemes m�s grans que suposa �s el temps. Generar un moodboard utilitzant aquest tipus de composici� pot suposar una gran quantitat de temps, ja que en primer lloc necessitem buscar aquelles imatges que necessitem, �s a dir, dintre d'un rang enorme el qual est� format per milers de mobles i objectes escollir els adients segons l'estil i l'estan�a desitjada. \\\\
Un cop seleccionats els elements necessaris cal editar-los un per un per tal de poder combinar-los entre ells i que sembli una fotografia. Tot plegat suposa un esfor� i una gran quantitat de temps per a generar un moodboard.\\\\
Per altra banda uns dels millors aspectes �s la cohesi� que s'aconsegueix i la impressi� que provoca, ja que sembla una fotografia. Aix� el que ens permet �s imaginar-nos molt millor com seria aquella habitaci�. Ens proporciona una visi� molt m�s real que un conjunt d'imatges ajuntades aleat�riament.\\\\
La q�esti� que ens plantegem �s si la gran quantitat de temps invertida per a generar una sola imatge compensa el resultat obtingut. Per tal de respondre aquesta pregunta, hem consultat a experts que una de les seves principals tasques �s la generaci� de moodboards.\\\\
Segons ells invertir una gran quantitat de temps per a generar una imatge compensa, ja que el resultat que obtenen �s una reflexi� de com seria veure en directe, com fer una fotografia de l'habitaci� per tal de poder-la mostrar.
Tamb� afirmen que a l'hora de mostrar habitacions a clients o empreses �s una de les formes de captar m�s la seva atenci� perqu� en aquestes imatges es reflecteix la realitat del futur, �s a dir, es reflecteix el que un dia podr� ser aquesta habitaci� en una casa qualsevol.\\\\ Tamb� han apuntat que en realitzar aquestes composicions els hi permeten crear diferents habitacions, diferents formes en ambients totalment diferents i poder afegir una hist�ria a darrere de cada composici� que permeti a la persona que est� veient aquella imatge entendre, endinsar-se dintre d'aquell ambient fictici fins a fer-lo real en la seva ment.\\\
Aix� doncs, la generaci� de moodboards utilitzat aquesta t�cnica genera molt bons resultats per� t� com a conseq��ncia dedicar-hi molt de temps per tal d'obtenir un bon resultat i que captivi aquelles persones a les quals va dirigit. \\\\
A partir d'aquest punt el que ens hem de plantejar si utilitzar l'esquema de la t�cnica anterior �s adient pel nostre projecte, �s a dir, si ens podem permetre generar una gran quantitat d'imatges dedicant-hi molt de temps per despr�s utilitzar-les per entrenar una m�quina.\\\\
La resposta �s simple, aquest tipus de t�cnica no serveix per a aquest cas, ja que necessitem generar, amb un per�ode curt de temps, una gran quantitat de moodboards. Per tal de solucionar-ho, s'ha de plantejar una soluci� que ens permeti organitzar en un moodboard els elements d'una forma r�pida i que m�s o menys formin una imatge cohesionada. \\\
Partint d'aquesta premissa es van agafar diferents estudis realitzats sobre moodboards anteriorment generats de cada estan�a i es van treure una s�rie d'especificacions que cada moodboard hauria de complir, aix� podr�em definir un model, una plantilla per a generar moodboards d'una forma m�s mec�nica i m�s r�pida.\\\\
Aix� doncs una de les especificacions m�s importants que es va arribar �s que cada estan�a que es volia generar tenia una s�rie d'elements fixes, �s a dir, una s�rie de mobles i objectes que sempre hi haurien de ser. D'aquesta forma es va establir un nombre d'objectes per a cada estan�a i quins havien de ser. Aix� solucionava una part del problema que era saber quants objectes pod�em col�locar a cada moodboard. L'altre problema que va sorgir era com combinar imatges per tal d'aconseguir una imatge cohesionada semblant a les imatges que s'obtenien amb l'altra t�cnica. \\\
En aquest cas el rang d'objectes disponible era bastant gran, es tractava d'un conjunt d'uns 3000 objectes, i les imatges per a cada objecte eren \textit{thumbs}, imatges amb un fons blanc i l'objecte en petit centrat al mig del fons blanc. La soluci� de treure el fons blanc editant la imatge no era viable, ja que es tardaria molt i no era l'objectiu que vol�em aconseguir. \\\\
Partint de tot aix�, es va arribar a trobar una soluci� que complia amb les especificacions i m�s o menys s'obtenia un resultat coherent. Partint de les solucions anteriors es va establir una graella per a cada estan�a. Aquesta graella contindria a cada casella un tipus d'objecte, la qual m�s endavant contindria la imatge, el \textit{thumb} de l'objecte que fos d'aquell tipus. D'aquesta forma s'aconsegueix una certa cohesi�, ja que totes les imatges en tenir el mateix format es formaria una imatge de fons blanc amb petites imatges de cada objecte. Tot i aix�, sempre hi ha la condici� que a una cel�la no hi hagi cap element i quedi de color blanc. \\\\
Aquesta soluci� serviria per a totes les estances disponibles d'un habitatge per� si ens centrem amb el projecte, nom�s analitzarem una estan�a, el dormitori per tant en aquest cas tindrem una sola graella d'imatges que corresponent als objectes que es troben en l'estan�a. Aix� doncs es va establir que, en aquest cas, la graella del dormitori tindria 48 elements els quals correspondrien als diferents mobles i objectes que es poden col�locar.\\\
\begin{figure}[h!]
\begin{center}
\begin{tikzpicture}
\draw[step=1cm,gray,very thin] (-2,-2) grid (6,4);
\draw[thick,->] (-3,-3) -- (6,-3) node[anchor=north west] {8}; 
\draw[thick,->] (-3,-3) -- (-3,4) node[anchor=south east] {6}; 
\end{tikzpicture}
\caption{Exemple de la graella de l'estan�a dormitori.}
\end{center}
\end{figure}
\\\\
Cada casella d'aquesta graella tindr� internament, �s a dir, d'una forma que no es veur� visualment uns valors que indicaran quins objectes poden anar aquella casella. D'altra banda cada casella tamb� contindr� una o m�s d'una paraula que descriur� els valors anteriors, d'aquesta forma la persona que hagi d'emplenar la graella amb objectes ha de saber quins poden i quins no. A continuaci� es mostra la graella final que s'utilitzar� per a la generaci� de moodboards.
\newpage
\begin{figure}[h!]
\begin{center}
\frame{\includegraphics[width=\textwidth]{graella}}
\caption{Graella final de l'estan�a dormitori.}
\end{center}
\end{figure}
A partir d'aquest punt ja tenim una soluci� que ens permet generar moodboards de forma r�pida encara que el resultat no sigui el mateix que utilitzant la primera t�cnica descrita. Tot i aix�, en aquest cas preferim velocitat a l'hora de generar que m�s cohesi�, ja que tampoc tenim forma que un cop la m�quina generi graelles pugui editar aquestes imatges per tal que s'assemblin al model de la primera t�cnica. A partir d'ara necessitem una forma de poder col�locar els objectes disponibles a la graella d'una forma senzilla i eficient.\\\
\newpage
\subsection{Desenvolupament de l'eina}

Per tal de poder aplicar el m�tode anteriorment explicat necessitem alguna eina que ens permeti accedir a tots els objectes disponibles d'una forma f�cil per tal de poder crear moodboards seguint la graella pr�viament definida. Aix� doncs necessitem crear una eina per realitzar aquesta tasca. \\\\
Aquesta eina que volem desenvolupar ha de ser f�cil de fer servir, intu�tiva i r�pida. Partint d'aix� s'ha de decidir quines tecnologies utilitzar per desenvolupar-la. En aquest cas, com que ja s'havien creat altres eines per altres coses es va decidir aplicar les mateixes tecnologies que en aquest cas s�n utilitzar Unity i el llenguatge de programaci� C sharp.\\\\
Aquestes dues tecnologies combinades ens permetran desenvolupar una eina capa� de generar moodboards d'una forma r�pida i eficient.\\\\
En primer lloc tenim la part de Unity que ens permetr� crear tot el disseny de la interf�cie i les interaccions necess�ries perqu� l'usuari pugui col�locar els objectes i aix� generar moodboards. Tamb� ens permetr� visualitzar tots els objectes i tota la informaci� que necessitem per a la generaci�. \\\\
I en segon lloc la part de C Sharp que controlar� tot la l�gica que hi ha darrere de la interf�cie. Per� el paper m�s important �s la connexi� amb la base de dades. Els objectes que tenim disponibles, la seva informaci�, la graella creada i tots els moodboards generats es guarden en una base de dades que es troba en un servidor. Aix� doncs per tal de poder accedir a aquesta informaci�, s'han realitzat crides constants per obtenir-la i aix� se n'encarrega la part l�gica de l'aplicaci�. \\\\
Pensant en un esquema model-vista-controlador (MVC), la part de model i vista correspondrien a Unity mentre que tota la part del controlador seria gestionada per fitxers, scripts, amb C Sharp els quals s'han de comunicar amb la base de dades per tal de proporciona la informaci� necess�ria per a mostrar tots els objectes, la graella i altres funcions que ja explicarem.
\subsubsection{Funcionalitats b�siques}
Com hem comentat aquesta eina ha de tenir unes funcionalitats b�siques i essencials per a obtenir un bon resultat. Aquestes funcionalitats s�n les seg�ents:
\begin{itemize}
\item Categoritzar graella predefinida. Com hem dit anteriorment, la graella la qual estableix quin objecte pot anar a cada casella, est� organitzada de forma que cada una d'elles cont� una s�rie d'identificadors els quals cada un �s una subcategoria, un tipus d'objecte de la base de dades. Aquests identificadors no es veuen a la graella, ja que no tenen import�ncia visualment per� el que s� que es veu �s un resum d'aquestes categories que especifica de forma m�s general la casella.\\\\
Aquests noms i aquests valors s'han de poder modificar per si en algun moment s'ha classificat una casella incorrectament. Aix� doncs, l'eina ens ha de permetre modificar cada una de les caselles, tant la part visual com els valors que no es mostren que en permeten filtrar objectes.\\\
\item Carregar objectes. Com hem mencionat repetidament necessitem objectes per a col�locar. Aquests objectes es troben a una base de dades i el que l'eina ha de fer �s obtenir la informaci� d'aquests i mostrar-la en forma d'imatges per tal que l'usuari pugui col�locar-los correctament a la graella. Aix� doncs ha d'implementar un sistema de crides a servidor per obtenir les dades i transformar-les per tal que es mostrin correctament i s'emmagatzemi d'alguna forma la informaci� que posteriorment ens ser� �til.\\\
\item Filtrar objectes. El rang disponible d'objectes �s molt ampli i el que no volem �s que l'usuari es passi molt de temps buscant un objecte per a col�locar-lo a una casella. Per tant, el que es necessita �s implementar un sistema de filtratge r�pid i f�cil de fer servir.\\\
Per tal d'implementar aquest sistema utilitzarem els valors que amaguen les caselles que s�n els que ens indiquen aquells objectes que poden anar en ella. Aix� doncs cada cop que es vulgui col�locar un objecte a una casella nom�s es mostraran aquells objectes que la base de dades retornar� aplicant el filtre amb els valors de la casella. D'aquesta forma aconseguim que l'usuari no s'hagi de trencar al cap buscant objectes i sempre col�loqui objectes v�lids a cada casella. \\\
A part tamb� s'han de poder filtrar aquests objectes, els que ja han estat filtrats, segons cada valor de la casella, �s a dir, ha d'haver-hi l'opci� de mostrar tots els objectes disponibles de la casella o nom�s els d'un tipus determinat de la casella, nom�s utilitzant un valor de la casella.\\\
\item Col�locar objectes. L'aplicaci� ha de permetre a l'usuari poder col�locar objectes a la graella. Aix� doncs, la mec�nica �s que pugui arrossegar la imatge de l'objecte a la graella. Tamb� ha de permetre que un cop col�locat l'objecte aquest es pugui treure i/o eliminar.
\item Guardar graella. Com que el principal objectiu de l'aplicaci� �s generar moodboards per despr�s entrenar una m�quina amb els moodboards generats, l'aplicaci� ens ha de permetre guardar d'alguna forma el moodboard generat amb tota la distribuci� d'objectes creada per l'usuari. El format d'aquestes dades que s'exportaran ha de ser l'adient per tal que la m�quina pugui llegir-les.
\item Crear PDF. Tot i que nom�s necessitem exportar les dades per la m�quina tamb� s'ha demanat una forma de visualitzar els moodboards generats i la informaci� que contenen. Aix� doncs, l'aplicaci� ha de permetre generar d'alguna forma un fitxer on figuri tota la informaci�. La soluci� �s generar un PDF. Aquest fitxer, en primer lloc contindr� una captura de la graella i els seus elements i a continuaci� a cada p�gina contindr� l'objecte amb tota la seva informaci�, aix� obtenim un fitxer f�cil de compartir i el qual cont� tota la informaci� del moodboard generat.
\end{itemize}
\subsubsection{Disseny i funcionament de l'aplicaci�}
A continuaci� explicarem el disseny de l'aplicaci�, �s a dir, com �s la interf�cie gr�fica, per a qu� serveix cada part que se'ns mostra. Per explicar-ho millor partirem d'una imatge de l'eina, ja que ens servir� per anar assenyalant millor les parts i indicant que fa cada part. M�s endavant explicarem quin proc�s s'ha de seguir per a crear un moodboard. A continuaci� es mostra la imatge de l'eina.\\\\
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{eina}
\caption{Captura de l'eina.}
\end{center}
\end{figure}
\\\\
Podem observar que es tracta d'una interf�cie senzilla i ben organitzada. A l'hora de dissenyar l'eina es van tenir en compte totes les normes de disseny i d'usabilitat per tal que la distribuci� de la informaci� i dels botons fos la m�s adient per tal que l'usuari pogu�s treballar d'una forma r�pida i mec�nica.\\\\
Com podem observar l'eina es divideix en tres parts essencials els quals cadascuna correspon alguna de les necessitats m�s importants que s'han mencionat anteriorment. A continuaci� analitzarem les 3 zones per separat explicant el seu objectiu i el funcionament dintre de l'eina.\\\\
Primer de tot comen�arem per la zona 3, la graella. Aquesta graella �s la mateixa que s'ha mostrat pr�viament i s'ha explicat com estava formada. Podem observar que aquesta graella �s prou gran perqu� en col�locar un objecte aquest no sigui ni molt petit ni molt gros sin� la mida justa per tal que es pugui veure de quin objecte es tracte. Cada casella de la graella �s clicable, �s a dir, podem fer clic sobre la casella i aquesta quedar� ressaltada de color verd. El que ens permet �s que en seleccionar una casella els objectes es filtrin segons les categories de la casella. \\\\
Una altra funcionalitat de les caselles �s que si en comptes de fer clic amb el bot� esquerre del ratol� el realitzem amb el bot� dret, eliminarem l'objecte que es troba a la casella. Aquest funcionament permet a l'usuari una r�pida manipulaci� de les graelles per tal de poder trobar els objectes adients per a cada una i la facilitat d'eliminar i/o modificar sense la necessitat de realitzar m�s moviments dels necessaris. \\\\
Tal com hem mencionat abans la graella es pot modificar, es poden canviar les categories. Per tal de modificar-la necessitem entrar en el mode edici�, en aquest mode, en fer clic amb el bot� esquerre ens apareixer� una finestra la qual haurem d'indicar el nom que volem que es mostri i escollir les subcategories que desitgem. Per a escollir una subcategoria primer s'ha de seleccionar el tipus, despr�s la categoria i despr�s la subcategoria. \\\
Per entrar i sortir del mode edici� l'usuari nom�s ha de pr�mer la tecla "F1". Un cop acabada l'edici� de les graelles, es guardar� la configuraci� i es mantindr� fins que no torni a ser modificada de nou per l'usuari. A continuaci� es mostra una imatge de la finestra que apareix quan ens trobem en el mode edici�.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{edit}
\caption{Captura de la finestra del mode edici�.}
\end{center}
\end{figure}
\\\\
La graella es pot emplenar del tot o deixar caselles buides. No hi ha cap restricci� sobre els elements m�nims necessaris per a generar un moodboard.
\\\\
Un cop ja hem explicat l'element principal de l'eina a continuaci� ens centrarem amb la zona 1, la zona dels objectes. Com hem dit, necessitem visualitzar els diferents objectes que es troben a la base de dades, aix� doncs necessitem una zona en la qual podem veure i filtrar els diferents objectes. \\\
Nom�s d'iniciar l'aplicaci� els objectes que es mostraran s�n tots els objectes disponibles que tenim, ja que no s'ha seleccionat cap cel�la en concret. El rang d'objectes que tenim �s molt gran i cada objecte cont� una imatge que l'aplicaci� ha de descarregar. Aix� ens presenta un problema important que haurem de gestionar d'una forma especial.\\\\ El problema que se'ns presenta �s que no podem carregar tots els objectes amb les seves corresponents imatges, ja que aquesta c�rrega trigaria molt i podria fer lent la tasca de generaci� de moodboards. \\\
Per tal de solucionar aquest problema crearem un sistema de c�rrega semblant als buscadors de les p�gines web, les imatges s'aniran carregant a mesura que es mogui la barra de despla�ament o s'utilitzi la rodeta del ratol� per baixar la barra. Aquest sistema ens permet una c�rrega r�pida i fluida de les imatges sense la necessitat de carregar totes les imatges. Aix� doncs, en iniciar l'aplicaci� es mostraran un nombre finit d'imatges, aquest n�mero dependr� de la mida de la finestra, ja que com m�s gran m�s imatges es mostraran al principi, i a mesura que es vagi despla�ant cap avall s'aniran carregant les seg�ents imatges. \\\\
Tamb� s'ha implementat que un cop la imatge s'ha descarregat no es torni a descarregar, es vol imitar el sistema de mem�ria cach� per� en aquest cas les imatges es guarden internament en l'aplicaci� el que ens permet que un cop carregada una imatge ja no es tornar� a descarregar, conseq�entment, si s'han carregat tots els objectes amb les seves imatges, ja no es descarregaran m�s imatges i el filtratge d'objectes ser� m�s r�pid. Aquesta informaci� desapareixer� un cop l'aplicaci� es tanqui. \\\\
El filtratge d'objectes es realitzar� quan se seleccioni una cel�la. Les diferents opcions de filtratge es mostraran en el desplegable que es troba a la part superior. En tots els casos hi haur� una opci� que ser� el filtratge de totes les categories, �s a dir, de tots els objectes que poden anar a la cel�la i les altres opcions seran per filtrar per categoria, per escur�ar el rang d'objectes a col�locar. El sistema de c�rrega d'imatges del filtratge �s el mateix que s'ha explicat anteriorment, ja que si ja tenim imatges descarregades nom�s les hem de mostrar i en cas contrari, les descarreguem i les guardem per posteriors usos. \\\\
Tot el filtratge d'objectes s'obt� mitjan�ant crides a la base de dades aplicant els filtres que t� la cel�la. Un altre sistema seria, filtrar a partir de la llista d'objectes descarregats inicialment, per� aix� pot suposar que en algun moment s'afegeixi o es modifiqui un objecte mentre s'est� utilitzant l'aplicaci� i aquest no apareixeria en el filtratge per aix� utilitzem les crides a base de dades per obtenir la informaci� actualitzada. A continuaci� es mostra un exemple de com funciona el filtre un cop se selecciona una cel�la. Podem veure com la primera opci� �s la general, la que engloba les dues categories i despr�s podem filtrar per cada una d'elles.
\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{filter}
\caption{Captura del filtratge despr�s de seleccionar una cel�la.}
\end{center}
\end{figure}
\\\\
Un cop ja explicades dues de les parts de l'eina, finalment explicarem la part superior la qual es compon dels diferents botons de l'aplicaci� per a realitzar diferents accions. A continuaci� es mostra una imatge de la barra superior de botons. A partir d'aquestes imatges explicarem la funcionalitat de cada bot� a dins l'eina i les diferents parts que la formen.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{topbar}
\caption{Barra superior de l'aplicaci�.}
\end{center}
\end{figure}
\\\\
Seguint un ordre d'esquerra a dreta tenim en primer lloc dos botons que s�n els botons de desfer i refer. L'aplicaci� t� implementat un sistema de gesti� d'accions, �s a dir, cada cop que es realitza una acci� aquesta queda registrada a dins l'aplicaci�. Aix� el que ens permet �s tenir un control sobre elles i en qualsevol moment saber quines accions s'han realitzat. \\\\
A partir d'aquest sistema de gesti� hem implementat un sistema de desfer i refer que desf� o torna a fer les accions que s'han realitzat. Aix� permet que si en un punt ens hem equivocat i volem tornar endarrere no tinguem problema o si s'ha guardat per� ens hem equivocat puguem tornar a un punt anterior per seguir endavant. \\\
Aquest sistema guarda totes les accions que es realitza l'usuari amb el ratol�. Aquestes dues icones s'aniran il�luminant a mesura que sigui possible realitzar les accions, �s a dir, si no es pot retrocedir o no es pot refer, no es podr� interactuar amb el bot�, aix� s'evita que es realitzin accions no permeses. \\\\
Cada cop que es reinicia l'aplicaci� �s reseteja el sistema i es netegen les accions, quan es guarda un moodboard definitiu tamb� es netegen tot i que es pot seguir realitzant accions que seran afegides al sistema com a noves accions, �s a dir, com si es torn�s a crear el sistema de gesti�. Aix� permet indicar a l'usuari que ha guardat el que ha realitzat i que a partir d'aquest punt tot el que realitzi ser� un nou moodboard.\\\\
Despr�s dels botons de desfer i refer tenim el nom del moodboard. Aqu� �s on ens apareixer� el nom del moodboard que estem generant. En el desplegable tamb� ens apareixer� el nom dels moodboards anteriors que hem creat. Seleccionar un nom d'un moodboard que ja hem creat ens permet crear un nou moodboard amb el mateix o carregar-ne un de nou per a visualitzar-lo. \\\\
Per tal de crear un nou moodboard hem de pr�mer el bot� amb el s�mbol m�s. En pr�mer aquest bot� ens apareixer� una nova finestra en el qual ens demanar� que entrem unes dades. En primer lloc en demanar� el nom de l'estil, que potser qualsevol nom que l'usuari desitgi. Despr�s utilitzant un desplegable l'usuari ha de seleccionar a quina habitaci� correspon l'estil i finalment haur� de seleccionar el tipus que correspon. \\\
El tipus es refereix a la distribuci� d'attrezzo, �s a dir, la distribuci� d'objectes que es podrien posar a cada moble, a sobre, a sota, els complements per a cada moble que es podrien col�locar per acabar de completar el moodboard. Hi ha sis tipus respecte si estan ordenats o poc i amb quina quantitat. Quan s'afegeix un nou moodboard aquest s'afegir� autom�ticament al desplegable. A continuaci� es mostra la pantalla per afegir un nou moodboard.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{name}
\caption{Barra superior de l'aplicaci�.}
\end{center}
\end{figure}
\\\\
A continuaci� segueix el bot� per a carregar moodboards ja creats. Aix� ens permet visualitzar moodboards creats pr�viament. Per tal de poder carregar un moodboard correctament s'ha de seleccionar un moodboard. Per fer-ho nom�s cal obrir el desplegable i seleccionar el nom del moodboard desitjat. Si no se selecciona cap nom, la icona no estar� activa, ja que seleccionar un nom �s un requisit indispensable per tal de fer la c�rrega correctament. \\\\
Un cop es premi el bot� apareixeran els objectes a la graella segons la distribuci� del moodboard carregat. L'aparici� dels objectes pot ser una mica lenta, ja que per a cada casella ha de buscar l'objecte que hi ha d'anar i si aquest no t� imatge descarregar-la. Aquest proc�s pot ser lent, per� si tenim en compte que pr�viament s'han carregat totes les imatges de tots els objectes, la col�locaci� d'aquest ha de ser r�pida. \\\\
Com hem dit anteriorment, un moodboard pot contenir diferents distribucions d'objectes, aix� doncs, en carregar aquest moodboard tamb� hem de poder visualitzar totes les distribucions disponibles. Els dos botons del costat del bot� de carregar moodboards ens permetran mostrar les diferents distribucions que t� el moodboard. Nom�s de carregar el moodboard es mostrar� la primera distribuci� de totes. \\\
Si nom�s es disposa d'una distribuci�, els dos botons es trobaran inactius mentre que si hi ha m�s d'una distribuci� els botons s'aniran activant per permetre l'avan� o el retroc�s de les distribucions. En qualsevol dels casos, les distribucions si per algun motiu est� malament o s'han de modificar �s poder canviar els objectes que les formen. En cas de modificaci�, la distribuci� es guardar� segons el nom escollit, si es d�na el cas que �s el mateix nom, s'afegir� a la distribuci� corresponen i aquesta podr� ser carregada i visualitzada m�s endavant.
\\\\
Seguidament ens trobem amb el bot� de generaci� de PDF. Aquest bot� ens permetr� generar un PDF del moodboard actual en el qual apareixer� una captura de la graella amb els elements, amb el nom del moodboard i a continuaci� a cada una de les p�gines del fitxer, cada objecte amb la seva informaci� corresponent. \\\\
En fer clic sobre el bot� ens apareixer� una finestra en la qual ens indicar� a on volem guardar el PDF que es generar�. Un cop seleccionada la ruta nom�s hem de pr�mer el bot� de guardar i a continuaci� es generar� el PDF. Aquest proc�s pot tardar una miqueta, ja que generar un fitxer amb molta informaci� pot ser lent, d'aquesta forma, per indicar que el fitxer s'ha generat correctament, la icona es desactivar�, indicant que s'ha creat el fitxer correctament i que el PDF del moodboard actual ja s'ha generat. En cas de modificaci� del moodboard, es tornar� a activar la icona per a generar un nou fitxer del moodboard.
\\\\
Finalment trobem el bot� de guardar. Aquest bot� ens permet guardar el moodboard generat de forma que s'exporta en un format que despr�s ser� tractat per utilitzar-lo amb la m�quina. Per tal de poder guardar un moodboard �s necessari que aquest tingui un nom si no la icona de guardar no es trobar� activa.\\\
Si en guardar, no existeix cap moodboard amb el nom escollit, es crear� un nou fitxer en el qual s'emmagatzemaran els moodboards amb el mateix nom. En cas contrari, que ja existeixin moodboards amb el mateix nom, s'afegir� la distribuci� d'objectes al fitxer. D'aquesta forma, per un sol moodboard podem tenir diferents distribucions.\\\
S'ha desenvolupat d'aquesta forma per tal d'assegurar que el format en el qual cada moodboard �s exportat �s f�cilment manipulable per transformar-lo per un posterior tractament per entrenar la m�quina.
\subsubsection{Proc�s de generaci� d'un moodboard}
En aquest punt explicarem els passos a seguir per crear un moodboard correctament, per a generar un moodboard pas a pas utilitzant tota la informaci� pr�viament explicada. A continuaci� s'enumerar� cada pas i en acabat es mostrar� un diagrama de seq��ncia per tal d'entendre-ho millor.
\begin{enumerate}
\item \textbf{Obrir correctament l'aplicaci� i comprovar que es carreguen tots els objectes i la graella.} En cas contrari pot ser culpa de la connexi� a internet o la connexi� a base de dades.
\item \textbf{Categoritzar la graella.} En cas que la graella estigui buida categoritzar-la per tal de fer el filtratge d'objectes correctament.
\item \textbf{Escollir un nom o afegir-ne un de nou.} Escollir un nom pel moodboard per tal de poder guardar i generar el PDF en qualsevol moment.
\item \textbf{Emplenar graella.} Emplenar la graella amb els objectes necessaris fins a obtenir un moodboard correcte. Utilitzar les funcions de filtratge per tal de poder col�locar els objectes amb m�s precisi� i m�s efica�ment.
\item \textbf{Guardar moodboard.} Un cop s'hagi acabat d'emplenar el moodboard guardar el moodboard correctament per tal de no perdre els canvis realitzats.
\item \textbf{Generar PDF.} Un cop guardat el moodboard guardar el PDF per tenir una refer�ncia i una visualitzaci� r�pida del moodboard generat.
\end{enumerate}
A continuaci� es mostra un esquema de seq��ncia dels passos a realitzar de completar els passos anteriors. \\\\
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{diagram}
\caption{Digrama de seq��ncia per a generar un moodboard.}
\end{center}
\end{figure}
\\\\
\newpage
\section{Desenvolupament del Machine Learning}
La part m�s important de projecte no �s el desenvolupament de l'eina i el seu funcionament, sin� que �s la part del algorisme. L'algorisme �s el que ens permetr� generar autom�ticament moodboards un cop aquest s'hagi entrenat i �s el que ens permetr�, que la generaci� de moodboards sigui r�pida i autom�tica.\\\\
Aix� doncs, a continuaci� explicarem en qu� es basa l'algorisme que realitzarem, explicant una mica d'introducci� i hist�ria per posar en context. Tamb� explicarem els diferents tipus i quin d'ells s'ha escollit i com s'ha desenvolupat.
\subsection{Introducci� i antecedents}
Parlar avui d'Intel�lig�ncia Artificial no �s una novetat. Ni per a la gent ni per a les empreses o governs.\\\
Si b� sembla una q�esti� d'all� m�s naturalitzada per aquests dies, fins fa no molts anys enrere, parlar d'intel�lig�ncia artificial era un assumpte distant, dif�cil d'abordar, reservat nom�s per a entesos.\\\\
Avui en dia, es parla i s'aplica per q�estions tan b�siques com l'�s del homebanking, veure pel�l�cules en streaming o escoltar m�sica. Fins als cercadors com Google o Yahoo la utilitzen. I a les xarxes socials, els exemples de Facebook i Twitter lideren el segment.\\\
Cada vegada m�s, es llegeix i es comenta sobre intel�lig�ncia artificial en mitjans massius de comunicaci�, amb tota facilitat. Fins i tot, comen�a a guanyar un espai dintre del pressupost propi de les empreses al pa�s: la recerca per la reducci� dels costos i l'augment de la productivitat v�nen impulsant l'avan� en l'�s de solucions que involucren robots capa�os de conversar amb els clients i de sistemes que analitzen milers de dades en pocs segons. En alguns casos, el volum de recursos destinats a aquest segment est� previst que augmenti en m�s de cinc vegades en 2018, en relaci� a l'aplicat l'any passat.\\\\
Dins de l'ampli espectre que abasta la intel�lig�ncia artificial, es troba Machine Learning. \textbf{Per� que �s el Machine Learnig?}
\\\\
El machine learning, conegut en espanyol com aprenentatge autom�tic o aprenentatge de m�quina, va n�ixer com una idea ambiciosa de la IA en la d�cada dels 60. Per ser m�s exactes, va ser una subdisciplina de la IA, producte de les ci�ncies de la computaci� i les neuroci�ncies. \\\\
El que aquesta branca pretenia estudiar era el reconeixement de patrons (en els processos d'enginyeria, matem�tiques, computaci�, etc.) i l'aprenentatge per part de les computadores. En les albors de la IA, els investigadors estaven �vids per trobar una forma en la qual els ordinadors poguessin aprendre �nicament des de dades. \\\\
Va succeir amb el pas dels anys que el machine learning comen�ar a enfocar-se en diferents assumptes, com ara el raonament probabil�stic, investigaci� basada en l'estad�stica, recuperaci� d'informaci�, i va continuar aprofundint cada vegada m�s en el reconeixement de patrons (tots aquests assumptes aplicats a processos d'enginyeria, matem�tiques, computaci� i altres camps relacionats amb objectes f�sics o abstractes).\\\\
Aix� va ocasionar que en els 90 es separ�s de la IA per convertir-se en una disciplina per si sola, encara que molts puristes encara la consideren com a part de la IA. Ara, el principal objectiu del machine learning �s abordar i resoldre problemes pr�ctics en on s'apliqui qualsevol de les disciplines num�riques abans esmentades.\\\
Com vam establir pr�viament, �s un camp de les ci�ncies de la computaci� que, d'acord a Arthur Samuel el 1959, li d�na a les computadores l'habilitat d'aprendre sense ser expl�citament programades.
\\\\
Si aquesta definici� va resultar molt trivial, posem-d'aquesta manera: �s la idea que hi ha algoritmes que poden donar-te troballes o conclusions rellevants obtingudes d'un conjunt de dades, sense que l'�sser hum� hagi d'escriure instruccions o codis per aix�.
\\\
D'acord, per� qu� �s un algoritme? Doncs no �s altra cosa que una seq��ncia o s�rie d'instruccions, que representen la soluci� a un determinat problema.
\\\\
El prop�sit del machine learning �s que les persones i les m�quines treballin de la m�, aquestes m�quines han de ser capa�os d'aprendre com un hum� ho faria. Precisament aix� �s el que fan els algoritmes, permeten que les m�quines executin tasques, tant generals com espec�fiques.
Si b� al principi les seves funcions eren b�siques i es limitaven a filtrar emails, avui dia pot fer coses tan complexes com prediccions de tr�nsit en interseccions molt transitades, detectar c�ncer, mapejar llocs per generar projectes de construcci� en temps real, i fins i tot, definir la compatibilitat entre dues persones.\\\
El principal objectiu de tot aprenent (learner) �s desenvolupar la capacitat de generalitzar i associar. Quan tradu�m aix� a una m�quina o ordinador, significa que aquestes haurien de poder exercir-se amb precisi� i exactitud, tant en tasques familiars, com en activitats noves o imprevistes.
\\\\
\textbf{I com �s possible aix�?}
\\\\
Fent que repliquin les facultats cognitives de l'�sser hum�, formant models que "generalitzin" la informaci� que se'ls presenta per realitzar les seves prediccions. I l'ingredient clau en tota aquesta q�esti� s�n les dades.
\\\\
En realitat, l'origen i el format de les dades no �s tan rellevant, ja que el machine learning �s capa� d'assimilar una �mplia gamma d'aquests, el que es coneix com big data, per� aquest no els percep com a dades, sin� com una enorme llista d'exemples pr�ctics.
\\\
Podr�em dir que les seves algoritmes es divideixen principalment en tres grans categories: supervised learning (aprenentatge supervisat), unsupervised learning (aprenentatge no supervisat) i Reinforcement learning (aprenentatge per refor�). A continuaci�, detallarem les difer�ncies entre aquestes.
\\\\
Una vegada que comproves el f�cil i pr�ctic que resulta d'aplicar les t�cniques de machine learning a problemes que creies serien impossibles, �s quan comences a creure que podria resoldre pr�cticament qualsevol problema, sempre i quan hi hagi suficients dades ja que la falta de dades pot provocar problemes al desenvolupament.\\\\
Per al consumidor modern, el machine learning �s un facilitador clau de moltes de les seves tasques quotidianes. Des serveis de traducci�, a prediccions clim�tiques, fins endevinar el que els usuaris volen amb base a les seves activitats recents; les prestacions que ofereix s�n incomparables.
\\\
Pel que fa als negocis, moltes companyies han comen�at a incorporar aquesta tecnologia als seus sistemes operatius, amb grans expectatives de millorar i automatitzar els seus processos.
\\\\
At�s que el machine learning �s un sistema basat en el processament i an�lisi de dades que s�n tradu�ts a troballes, es pot aplicar a qualsevol camp que compti amb bases de dades prou grans. De moment, alguns dels seus usos m�s populars i desenvolupats s�n:
\begin{itemize}
\item Classificaci� de seq��ncies de DNA
\item Prediccions econ�miques i fluctuacions en el mercat borsari
\item Mapatges i modelats 3D
\item Detecci� de fraus
\item Diagn�stics m�dics
\item Cercadors a Internet
\item Sistemes de reconeixement de veu
\item Optimitzaci� i implementaci� de campanyes digitals publicit�ries
\end{itemize}
Un exemple de l'�ltim punt �s Adext. Adext �s el primer i �nic AMaaS (Audience Management as a Service) que aplica Intel�lig�ncia Artificial i Machine Learning a la publicitat digital per trobar la millor audi�ncia o grup demogr�fic per a qualsevol anunci. Gestiona de forma autom�tica els pressupostos al voltant de 16 p�blics diferents, en 3 plataformes (AdWords de Google, Facebook i Instagram), optimitzant diverses vegades al dia.\\\\
A m�s, se'ls garanteix sota contracte a les ag�ncies que siguin Adext Partners superar el cost per conversi� actual (cost per venda o cost per lead m�s baix) de tots els comptes o campanyes que portin com a ag�ncia. Altrament, el servei ser� gratis i no es cobra el fee corresponent.
\\\\
Tot i que ja hem vist el que la IA �s capa� d'aportar a les nostres activitats del dia a dia, com podria aix� beneficiar el m�n dels negocis?
\\\\
B�, ja que les converses i comentaris d'una infinitat de consumidors digitals -el nombre dia amb dia segueix incrementant- li ofereixen a aquest tipus de tecnologies una quantitat d'informaci� aclaparadora, aquestes cont�nuament obtenen coneixements nous i detecten tend�ncies m�s r�pid del que qualsevol hum� podria fer-ho.
\\\\
Si b� �s cert que aquesta enorme quantitat de dades la tornar� molt m�s eficient, requerir� necess�riament de molt talent hum� per perfeccionar-se, ja que finalment els ordinadors no tenen un domini tan elevat del llenguatge aplicat al raonament. O el que �s, no s�n precisament h�bils per determinar contextos.
\\\\
El que significa que perqu� el machine learning es desenvolupi en aquestes �rees, els experts en cada camp de treball hauran de trobar el temps per entrenar a les m�quines i anar incorporant paulatinament a cada un dels processos que desitgin afinar.
\\\\
Finalment, com succeeix amb totes les tecnologies, els negocis hauran de comen�ar per entendre els principis b�sics d'aquesta tecnologia, per poder usar-la a favor seu. Tamb� s'estima que aquesta -com molts altres derivats de la IA- transformar� per complet el m�n com el coneixem.
\\\\
Com podem observar aix� nom�s reflecteix una petita introducci� al intricat m�n del machine learning. En una �poca on emergeixen tecnologies innovadores cada vegada que parpellegem, �s f�cil perdre en l'allau d'informaci� i nous conceptes.
\newpage
\subsection{Tipus d'algoritmes}
Dintre del conjunt del Machine Learning poder distingir entre diferents tipus que ens definiran diferents tipus d'algoritmes a aplicar durant el desenvolupament d'una m�quina. Els principals tipus s�n els seg�ents:
\begin{itemize}
\item Aprenentatge supervisat
\item Aprenentatge no supervisat
\item Aprenentatge per refor�
\end{itemize}
A continuaci� s'analitzar� en profunditat cada un dels tipus anteriors. Seguidament mostra una imatge resum dels diferents tipus i un exemple de cada un. 
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{typesML}
\caption{Diagrama dels tipus i exemples.}
\end{center}
\end{figure}

\subsubsection{Aprenentatge supervisat}
En l'aprenentatge supervisat, els algorismes treballen amb dades etiquetades (labeled data), intentant trobar una funci� que, donades les variables d'entrada (input data), els assigni l'etiqueta de sortida adequada. L'algorisme s'entrena amb un hist�ric de dades i aix� apr�n a assignar l'etiqueta de sortida adequada a un nou valor, �s a dir, prediu el valor de sortida.
\\\\
Per exemple, un detector de spam, analitza l'hist�ric de missatges, veient que funci� pot representar, segons els par�metres d'entrada que es defineixin (el remitent, si el destinatari �s individual o part d'una llista, si l'assumpte cont� determinats termes, etc.), l'assignaci� de l'etiqueta spam o no �s spam. Una vegada definida aquesta funci�, en introduir un nou missatge no etiquetat, l'algorisme �s capa� d'assignar-li l'etiqueta correcta.
\\\\
L'aprenentatge supervisat se sol usar en problemes de classificaci�, com a identificaci� de d�gits, diagn�stics, o detecci� de frau d'identitat. Tamb� s'usa en problemes de regressi�, com a prediccions meteorol�giques, d'expectativa de vida, de creixement, etc. Aquests dos tipus principals d'aprenentatge supervisat, classificaci� i regressi�, es distingeixen pel tipus de variable objectiu. En els casos de classificaci�, �s de tipus categ�ric, mentre que, en els casos de regressi�, la variable objectiu �s de tipus num�ric.
\\\\
Alguns dels m�s freq�ents en aprenentatge supervisat:
\\\
\begin{enumerate}
\item Arbres de decisi�
\item Classificaci� de Na�ve Bayes
\item Regressi� per m�nims quadrats
\item Regressi� Log�stica
\item Support Vector Machines (SVM)
\end{enumerate}
\begin{figure}[h!]
\begin{center}
\includegraphics[width=.8\textwidth]{supervised}
\caption{Diagrama d'un algorisme amb aprenentatge supervisat.}
\end{center}
\end{figure}
\newpage
\subsubsection{Aprenentatge no supervisat}
L'aprenentatge no supervisat t� lloc quan no es disposa de dades etiquetades per a l'entrenament. Nom�s coneixem les dades d'entrada, per� no existeixen dades de sortida que corresponguin a un determinat input. Per tant, nom�s podem descriure l'estructura de les dades, per intentar trobar algun tipus d'organitzaci� que simplifiqui l'an�lisi. Per aix�, tenen un car�cter exploratori.
\\\\
Per exemple, les tasques de clustering, busquen agrupaments basats en similituds, per� gens garanteix que aquestes tinguin algun significat o utilitat. A vegades, en explorar les dades sense un objectiu definit, es poden trobar correlacions espor�diques curioses, per� poc pr�ctiques. \\\\
L'aprenentatge no supervisat se sol usar en problemes de clustering, agrupaments de co-ocurr�ncia i profiling. Tanmateix, els problemes que impliquen tasques de trobar similitud, predicci� d'enlla�os o reducci� de dades, poden ser supervisats o no.
\\\\
Els algorismes no supervisats es poden usar per diferents tasques. Una tasca for�a cl�ssica �s  la de trobar grups dins a les dades.  Podem usar algorismes de clustering que ens permeten associar a dades uns representants (centroides dels cl�sters). Aix� pot ser �til, per exemple, per a trobar grups de usuaris amb caracter�stiques comuns. 
Una altra tasca diferent �s la de generar dades. En aquest treball ens centrem en usar models que permeten generar dades a partir de unes dades de entrenament, no en trobar grups a les dades. 

%\begin{enumerate}
%\item Algorismes de clustering
%\item An�lisi de components principals
%\item Descomposici� en valors singulars (singular value decomposition)
%%\item An�lisi de components independents (Independent Component Analysis)
%\end{enumerate}
%\begin{figure}[h!]
%\begin{center}
%\includegraphics[width=\textwidth]{unsupervised}
%\caption{Diagrama d'un algorisme amb aprenetatge no supervisat.}
%\end{center}
%\end{figure}

\newpage
\subsection{Plantejament de l'algoritme}
Un cop ja tenim els coneixements b�sics del machine learning necessitem pensar en quin algoritme necessitem per tal de poder aplicar-lo al nostre problema i desenvolupar-lo correctament. \\\\
Pel nostre problema disposarem de dades d'entrada no etiquetades, que seran les graelles de cada estil.  �s a dir, les dades d'entrada seran vectors que definiran graelles. Un estil pot tenir diferents graelles, per� totes aquestes estaran etiquetades. I el que es vol aconseguir, �s obtenir una graella nova donat un estil. \\\\
D'aquesta forma el nostre algoritme ha de ser un algoritme de classificaci� supervisat, ja que el que es vol obtenir �s classificar graelles per despr�s poder classificar-ne de noves i com que aquestes estan etiquetades aquest algoritme ser� supervisat. En aquests tipus d'algoritmes les dades segueixen un format est�ndard compost per dues parts, les etiquetes (labels) i els valors (features).\\\\
Les labels podr�em dir que �s l'output, el valor de sortida, el valor que obtenim despr�s de classificar les dades d'entrada. Aquestes etiquetes poden ser valors �nics o classes per� s�n els valors que ens permeten etiquetar les dades correctament. \\\\
Les features s�n variables individuals independents que actuen com a entrada al sistema. Els models de predicci� utilitzen funcions per fer prediccions. Tamb� es poden obtenir funcions noves a partir de funcions antigues mitjan�ant un m�tode conegut com a enginyeria de caracter�stiques. M�s simplement, podem considerar que una columna del conjunt de dades sigui una feature. De vegades, aquests tamb� s'anomenen atributs. I la quantitat de funcions s'anomenen dimensions. \\\
Aplicant aix� al nostre problema obtindr�em que les labels serien els estils i les features les diferents graelles que generem a partir de l'eina. \\\\
Els algoritmes de classificaci� esmentats anteriorment classifiquen features d'entrada, �s a dir, un cop entrenada la m�quina permet classificar qualsevol dada d'entrada i obtenir una label, classificar aquesta dada. Si apliquem aquest comportament al nostre problema, obtindr�em que donada una graella la podr�em classificar, podr�em dir de l'estil que �s, de l'estil que pertany, per� aix�, no �s el que nosaltres volem aconseguir.\\\\
El que volem aconseguir �s que donat un estil ens generi una graella nova que segueixi les normes d'aquell estil que ha apr�s la m�quina. Volem que les nostres features siguin els estils i les labels les graelles per� aix� no pot funcionar, ja que les labels han de ser valors �nics o classes i les nostres graelles s�n vectors amb vectors, �s una llista de dues dimensions. Aix� doncs necessitem un algoritme que ens permeti generar valors.  \\\
Aix� doncs la nostra primera premissa de fer aprenentatge supervisat queda anul�lada i em de partir de la premissa que necessitem desenvolupar l'algoritme utilitzant aprenentatge no supervisat.\\\\
Dintre del machine learning hi ha uns algoritmes que ens permeten generar valor a partir dels valors d'entrada, aquests algoritmes s�n els algoritmes generatius i discriminatius.\\\\
Els algoritmes generatius s�n un model per a generar valors aleatoris d'una dada observable, t�picament donats alguns par�metres ocults. Els algoritmes generadors contrasten amb els models discriminadors; un algoritme generador �s un gran model probabilista de totes les variables, mentre que un algoritme discriminador proporciona un model sol per les variables etiquetades com a condicionals sobre les variables observades. \\\
Per aix� un model generador pot ser utilitzat, per exemple, per simular (i.e. generar) valors de qualsevol variable en el model, mentre que un algoritme discriminador permet el mostreig �nic de les variables condicionals. A la pr�ctica les dues classes s�n vistes com a complement�ries o com diferents observacions del mateix procediment.\\\\
Aix� doncs, el que necessitem per al nostre problema �s un algoritme generatiu que donats una s�rie de vectors que formen un estil, la m�quina sigui capa� de generar una nova graella. Tot i aix�, aquest model ens provoca una restricci� que �s que haurem de tenir una m�quina entrenada per a cada estil, ja que aix� aconseguim que els resultats siguin m�s precisos i correctes, ja que nom�s permetrem que es generin graelles d'un estil per a cada m�quina.\\\\
Tenim diferents tipus d'algoritmes generatius. Els m�s coneguts s�n els seg�ents:
\begin{itemize}
\item Model de barreja gaussiana i altres tipus de model de mescla
\item Model ocult de Markov
\item Gram�tica lliure de context probabil�stica
\item Classificador bayesi� ingenu
\item Averaged one-dependence estimators
\item Latent Dirichlet Allocation
\item Restricted Boltzman machine
\end{itemize}
Despr�s d'investigar entre totes les diferents opcions, vam arribar a la conclusi� que la millor opci� era utilitzar una M�quina de Boltzmann Restrictiva (RBM) que ens permetria generar graelles a partir de les graelles ja generades anteriorment. Aquest tipus de m�quina t� algunes restriccions a l'hora d'entrar les dades, ja que han de seguir un format espec�fic, a continuaci� explicarem com funciona aquest tipus d'algoritme i les seves caracter�stiques.
\newpage
\section{M�quina de Boltzmann(BM) i M�quina de Boltzmann Restrictiva (RBM)}
A continuaci� explicarem d'una forma m�s detallada les m�quines de Boltzmann i la seva variant, que �s la que utilitzarem, la m�quina de Boltzmann Restrictiva. B�sicament ens centrarem en com entrenar i avaluar les m�quines utilitzant el gradient estoc�stic i analitzar les seves dificultats. Tamb� analitzarem els seus avantatges i inconvenients.
\subsection{M�quina de Boltzmann}
La m�quina Boltzmann (BM) �s una xarxa neuronal recurrent estoc�stica que consisteix en neurones bin�ries. La xarxa est� totalment connectada i cada connexi� entre dues neurones �s sim�trica, de manera que l'efecte d'una neurona en l'estat de l'altra �s sim�trica per a cada parell.\\\\
La probabilitat d'un estat particular ${X = [x_1, x_2,...,x_d]^T}$ de la xarxa es defineix per l'energia de BM que es postula com 
\[E (x | \theta) = -\sum_{i}\sum_{j>i}w_{ij}x_ix_j - \sum_{i}b_ix_i\]
on ${\theta}$ indica par�metres de la xarxa que consisteixen en una matriu de pes ${W = [w_{ij}]}$ i un vector de polaritzaci� ${b = [b_i]}$. ${w_{ij}}$ �s el pes de les connexions sin�ptiques entre les neurones i i j. Suposem que ${w_{ij}}$ = 0 i ${w_{ij}}$ = ${w_{ji}}$. La probabilitat d'un estat x �s, doncs, 
\begin{equation}
P (x | \theta) = \frac{1}{Z}exp[-E(x|\theta)] 
\end{equation}
on
\[Z (\theta) = \sum_{x}exp[-E(x|\theta)]\]

 �s la constant de normalitzaci�. Es dedueix de (4.1) que la probabilitat condicional d'una sola neurona que sigui 0 o 1 donada als estats de les altres neurones es pot escriure de la seg�ent manera: 
\begin{equation}
P(x_i = 1|(x_{\setminus i},W)) = \frac{1}{1 + exp(-\sum_{j\neq i}w_{ij}x_j - b_i)}
\end{equation}
on ${x_{\setminus i}}$ denota un vector ${[x_1,...,x_{i-1},x_{i+1},..., x_d]^T }$. \\\\
Les neurones de BM solen estar dividides en visibles i ocultes ${x = [v^T, h^t]^T}$, on els estats v de les neurones visibles es subjecten a les dades observades, i els estats h de les neurones ocultes poden canviar lliurement. En aquest cas de tenir neurones visibles i ocultes, es pot calcular la probabilitat d'una configuraci� espec�fica de les neurones visibles marginant les neurones ocultes.\\\\
\subsubsection{Entrenament M�quina de Boltzmann}
Els par�metres de BM es poden obtenir a partir de les dades utilitzant l'estimaci� est�ndard de m�xima versemblan�a. Donat un conjunt de dades ${}$, la probabilitat de registre dels par�metres de BM �s 
\begin{equation}
\mathcal{L}(\theta) = \sum_{t=1}^N logP(v^{(t)}|\theta) =  \sum_{t=1}^N log \sum_h P(v^{(t)},h|\theta)
\end{equation} 
on les mostres ${v^{(t)}}$ s s'assumeixen que s�n independents entre si, i els estats h de les neurones ocultes han de ser marginades.\\\\
El gradient de la probabilitat de registre s'obt� prenent derivada parcial de ${\mathcal{L}(\theta)}$ respecte als par�metres ${w_{ij}}$ 
\[\frac{\partial\mathcal{L}}{\partial w_{ij}} = \frac{N}{2} [\langle x_ix_j \rangle_d - \langle x_ix_j \rangle_m] \]
on una notaci� abreviada ${\langle\cdot\rangle_{P(\cdot)}}$ que denota l'expectativa calculada sobre la distribuci� de probabilitat ${P(\cdot)}$. A m�s, es van utilitzar ${d}$ i ${m}$ per designar dues distribucions de probabilitat ${P(h|\{v^{(t)}\},\theta)}$ i ${P(x|\theta)}$, respectivament. S�n la probabilitat de les neurones ocultes quan les neurones visibles es subjecten a les mostres, i la probabilitat de totes les neurones sense cap neurona fixa. \\\\
Segons el signe de cada terme, els dos termes es poden anomenar la fase positiva i la fase negativa, respectivament. La f�rmula d'actualitzaci� general d'un par�metre ${w_{ij}}$ �s 
\begin{equation}
w_{ij}\leftarrow w_{ij} + \eta [\langle x_ix_j \rangle_d - \langle x_ix_j \rangle_m]
\end{equation}
on ${\eta}$ denota la taxa d'aprenentatge. \\\\
Aix� doncs, a partir d'aqu�, deixem que ${b}$ sigui nom�s un vector de biaixos ${b_i}$ de les neurones visibles, i ${c}$ sigui un vector dels biaixos de les neurones ocultes. A continuaci�, per als biaixos separats de les neurones visibles i ocultes, les regles d'actualitzaci� s�n, en analogia amb la regla d'actualitzaci� dels pesos, 
\begin{equation}
b_{i}\leftarrow b_{i} + \eta [\langle v_i \rangle_d - \langle v_i \rangle_m]
\end{equation} 
i 
\begin{equation}
c_{j}\leftarrow b_{j} + \eta [\langle h_j \rangle_d - \langle h_j \rangle_m]
\end{equation} 
on ${v_i}$, ${h_j}$, ${b_{i}}$ i ${c_{j}}$ denoten la i i la neurona visible, la ${j}$-oculta neurona, el $i{}$-biaix visible, i el ${j}$ biaix amagat.
\newpage
Tot i que les regles d'activaci� i aprenentatge de la BM estan clarament formulades, hi ha limitacions pr�ctiques en l'�s de la BM. Especialment, les f�rmules d'actualitzaci� basades en gradients (4.4) - (4.6) no s�n computacionalment factibles, ja que les distribucions requerides tant en les fases positives com negatives nom�s es poden obtenir despr�s de computar la constant de normalitzaci� ${Z(\theta)}$.\\\\
\begin{algorithm}
\caption{ Passos de mostreig de Gibbs per al BM general}
\begin{algorithmic} 
\STATE Dibuixa $x_0$ uniformement des de l'espai de l'estat.
\REPEAT 
\FOR{$i = 1 ... d$} \STATE {Mostreig $x_i$ fent l'equaci� (3.2)} \ENDFOR 
\UNTIL{que es reculli el nombre suficient de mostres, o el mostreig de Gibbs hagi arribat a l'equilibri.}
\end{algorithmic}
\end{algorithm}\\\\
La computaci� ${Z(\theta)}$, tanmateix, requereix sumar de forma exponencial moltes possibles configuracions de BM, i �s senzillament impossible per a les BM grans.\\\\
Un m�tode obvi per evitar la computaci� de la constant de normalitzaci� �s utilitzar els m�todes de mostreig Markov-Chain Monte-Carlo (MCMC) per calcular el gradient estoc�stic. A causa de la simplicitat de la regla d'activaci� d'una �nica neurona donada als estats d'altres neurones, un simple mostreig de Gibbs �s suficient per obtenir gradients estoc�stics. \\\\
El mostreig de Gibbs es pot implementar f�cilment perqu� la distribuci� condicional de l'estat d'una sola neurona a BM donada als estats de totes les altres neurones ve donada per (4.2). Una descripci� senzilla sobre com realitzar el mostreig de Gibbs amb BM es descriu en Algorisme 1. \\\\
Aquest enfocament pot reduir considerablement la c�rrega computacional de les regles d'actualitzaci� de gradients. Si s'assumeix que la quantitat de mostres necess�ries per explicar la distribuci� de probabilitat de tot l'espai estatal �s prou menor que la mida de l'espai estatal, �s a dir, el nombre de totes les combinacions possibles dels estats de les neurones, l'aprenentatge de BM ja no �s computacional inviable.\\\\
Tanmateix, tamb� existeixen altres tipus de limitacions en l'�s del mostreig de Gibbs per a la formaci� de BM. El major problema es deu a la connectivitat completa de BM. At�s que cada neurona est� connectada i influ�da per totes les altres neurones, es necessiten tants passos com la quantitat de neurones per obtenir una mostra de l'estat de BM. Fins i tot quan les neurones visibles es mantenen subjectes a les dades de formaci�, el nombre de passos necessaris per a una sola mostra fresca encara �s almenys el nombre de neurones ocultes. Aix� fa que les mostres successives de la cadena estiguin altament correlacionades entre elles i aquesta pobra barreja afecta el rendiment de l'aprenentatge. \\\\
Una altra limitaci� d'aquest enfocament �s que les distribucions multi modals s�n problem�tiques per al mostreig de Gibbs \cite{salakhutdinov}. A causa de la naturalesa del mostreig de components, les mostres poden perdre alguns modes de distribuci�.
\subsection{M�quina de Boltzmann Restrictiva}
Per superar les limitacions pr�ctiques imposades a la m�quina general Boltzmann com el problema del mostreig ineficient, Smolensky va proposar una versi� estructuralment restringida de la m�quina Boltzmann anomenada Restringit Boltzmann Machine (RBM). Un RBM es construeix eliminant les connexions laterals entre les neurones visibles i les neurones ocultes. Per tant, una neurona visible nom�s tindria vores connectades a les neurones ocultes, i una neurona oculta nom�s tindria vores connectades a les neurones visibles. Ara, l'estructura d'un RBM es pot dividir en dues capes amb vores interconnectats. La relaci� entre BM i RBM s'il�lustra a la figura 11. 
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{boltzmann1}
\caption{Il�lustraci� de la relaci� entre la m�quina Boltzmann i la m�quina restrictiva de Boltzmann.}
\end{center}
\end{figure}
\\\\
Tot i que la restricci� imposada podria suggerir que el poder de representaci� podria haver estat redu�t, Le Roux and Bengio van demostrar que un RBM �s una aproximaci� universal que pot modelar qualsevol distribuci� de probabilitat discreta \cite{leroux}.\\\\
A causa d'aquesta restricci�, l'energia i la probabilitat de l'estat han de ser modificades en conseq��ncia a la seg�ents f�rmules:
\begin{equation}
\begin{array}{l}
E(v,h|\theta) = -v^TWh-b^Tv-c^Th \\\\
P(v,h|\theta) = \frac{1}{Z(\theta)}exp\{-E(v,h|\theta)\}
\end{array}
\end{equation}
on ara els par�metres ${\theta = (W,b,c)}$ inclouen els biaixos ${b}$ i ${c}$.\\\\
At�s que cada neurona oculta �s independent una de l'altra donada totes les neurones visibles, �s possible extreure expl�citament les neurones ocultes i obtenir la probabilitat no normalitzada de les neurones visibles. La probabilitat d'un estat de neurones visibles v �s, doncs,
\begin{equation}
P(v|\theta) = \frac{1}{Z(\theta)}exp(b^tv)\prod_{j=1}^{n_h}(1 + exp(c_j + \sum_{i=1}^{n_v}w_{ij}v_i))
\end{equation}
on ${n_v}$ i ${n_h}$ s�n el n�mero de neurones visibles i invisibles respectivament.\\\\
\subsubsection{Entrenament M�quina de Boltzmann Restrictiva}
D'aquesta forma les regles d'aprenentatge d'un RBM passen a ser:
\begin{equation}
w_{ij}\leftarrow w_{ij} + \eta_w[\langle v_i h_j\rangle_d - \langle v_i h_j \rangle_m]
\end{equation}
\begin{equation}
b_{i}\leftarrow b_{i} + \eta_b[\langle v_i\rangle_d - \langle v_i  \rangle_m]
\end{equation}
\begin{equation}
c_{j}\leftarrow c_{j} + \eta_c[\langle v_i \rangle_d - \langle v_i \rangle_m]
\end{equation} \\\\
on s'utilitza la mateixa notaci� ${\langle \cdot \rangle_{P_{(\cdot)}}}$ que s'ha usat anteriorment. \\\\
Encara que no hi ha un fons te�ric rigor�s sobre l'elecci� de les taxes d'aprenentatge, tradicionalment, s'utilitzen taxes d'aprenentatge m�s petites per aprendre els dos biaixos.\\\\
At�s que un RBM �s un cas especial de BM, �s possible utilitzar el mateix mostreig de Gibbs per aprendre. Gr�cies a la seva estructura restringida, el mostreig de Gibbs es pot utilitzar de manera m�s eficient, ja que una capa, ja sigui visible o oculta, les neurones de l'altra capa es converteixen en independents m�tuament (veure Figura 12). Aquesta possibilitat de la presa de mostres capa� permet la plena utilitzaci� de l'entorn inform�tic paral�lel modern.\\\\
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{rbm_hidden}
\caption{Visualitzaci� de la idea de com es realitza el mostreig de Gibbs en capes RBM.}
\end{center}
\end{figure}
Tanmateix, a mesura que augmenta el nombre de neurones en un RBM, el mostreig de Gibbs hauria de recollir un nombre m�s gran de mostres per explicar correctament la distribuci� de probabilitat que representa el RBM. A m�s, a causa de la naturalesa de les mostres de Gibbs, les mostres encara podrien perdre alguns modes de la distribuci�.\\\\
S'han proposat molts enfocaments per superar aquestes dificultats. Un enfocament popular �s l'aprenentatge de diverg�ncia contrastiva (CD) com un m�tode aproximat per a la formaci� dels models Product-of-Expert. L'equaci� (4.8) implica directament que un RBM �s un cas especial de models PoE, i l'aprenentatge de CD pot ser utilitzat f�cilment per formar un RBM.\\\\
L'aprenentatge de CD s'aproxima al veritable gradient reempla�ant l'expectativa sobre ${P(v,h | \theta)}$ amb una expectativa sobre una distribuci� ${P_n}$ que s'obt� executant ${n}$ passos del mostreig de Gibbs a partir de la distribuci� emp�rica definida per les mostres d'entrenament. La figura 13 il�lustra les distribucions ${P_0}$ i ${P_n}$.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{cd}
\caption{Visualitzaci� de com l'aprenentatge del CD obt� la distribuci� emp�rica utilitzada en la fase positiva i la distribuci� del model aproximat utilitzada en la fase negativa. A la figura, cada fila representa la cadena de mostreig de Gibbs a partir de cada mostra de dades de formaci�, i ${P_0}$ i ${P_n}$ indiquen la distribuci� emp�rica i la distribuci� del model aproximat, respectivament.}
\end{center}
\end{figure}
\\\\
Per als pesos, la f�rmula d'aprenentatge dels CD, llavors, es defineix com
\begin{equation}
w_{ij}\leftarrow w_{ij} + \eta[\langle x_i h_j\rangle_{P_0} - \langle x_i h_j \rangle_{P_n}]
\end{equation}
Cal assenyalar que el cas ${n = 0}$ produeix la distribuci� emp�rica ${P(h|\{v^{(t)}\},\theta)}$ utilitzada en la fase positiva, mentre que el cas${n = \infty}$ produeix la veritable distribuci� de la fase ${P(x|\theta)}$ \cite{carreira}. \\\\
Com es pot preveure del fet que la direcci� del gradient no �s id�ntica al gradient exacte, se sap que l'aprenentatge de CD est� parcial \cite{carreira}. No obstant aix�, s'ha demostrat que l'aprenentatge en CD funciona b� a la pr�ctica. Una bona propietat del CD �s que, en el cas que la distribuci� de dades sigui multimodal, les cadenes a partir de cada mostra de dades garanteix que les mostres que s'aproximen a la fase negativa tenen representants de diferents maneres.\\\\
Tanmateix, aquest avantatge de l'aprenentatge de CD �s el seu desavantatge alhora. Les mostres de ${P_n}$ no necess�riament expliquen tot l'espai estatal. Per tant, no s'exploren alguns dels modes de la distribuci� del model, i fins i tot despr�s de l'aprenentatge s'ha convergit, la distribuci� del model cont� els modes que no es troben en la distribuci� de dades definida pel conjunt de dades de formaci�. Aquest problema es mostra a la figura 14.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{model}
\caption{La figura esquerra mostra la distribuci� del model (blau) i les mostres d'entrenament (punts negres). Els punts blaus en la figura correcta indiquen les part�cules de fantasia obtingudes mitjan�ant l'aprenentatge de CD. �s evident que les part�cules de fantasia no van explicar tot l'espai en perdre el mode a la part superior.}
\end{center}
\end{figure}
\\\\
Per superar aquest problema, s'han proposat diferents enfocaments basats en l'aprenentatge de CD. Entre ells, l'aprenentatge persistent de diverg�ncia contrastiva (PCD) �s l'extensi� m�s senzilla de l'aprenentatge de CD.\\\\
A cada pas d'actualitzaci� de gradients, l'aprenentatge de CD realitza el mostreig de Gibbs a partir de les mostres de dades de formaci�, mentre que l'aprenentatge de PCD comen�a el mostreig a partir de mostres model obtingudes en l'�ltima actualitzaci� de degradat. D'aquesta manera, s'espera que les mostres del model exploren els modes de la distribuci� del model que no s�n pr�xims a les mostres d'entrenament.\\\\
Tanmateix, l'aprenentatge de PCD encara pateix els modes que falten en la distribuci� del model a mesura que avan�a l'aprenentatge. Es deu a la mala barreja del mostreig de Gibbs que produeix mostres altament correlacionades per actualitzacions successives de gradients. Aquest comportament fa que els enfocaments basats en l'aprenentatge en CD pateixin la diverg�ncia de la probabilitat si l'aprenentatge es realitza sense escollir manualment heur�stiques d'aprenentatge com ara el calendari de tarifes d'aprenentatge, la decad�ncia del pes i l'impuls.\\\\
S'han proposat recentment nombrosos enfocaments basats en l'aprenentatge de CDs diferents de l'aprenentatge de la PCD. Per exemple, s'ha proposat un aprenentatge que amplia l'aprenentatge de la PCD mantenint uns pesos r�pids que ajuden a obtenir millors models de mostres.\\\\
\subsubsection{Avaluaci� d'una RBM}
A continuaci� explicarem les formes d'avaluar una m�quina de boltzamn restrictiva. Tenim tres formes diferents per realitzar l'avaluaci�. En primer lloc tenim l'avaluaci�  per probabilitat i mostreig rellevant d'import�ncia.\\\\
Una forma natural d'avaluar el rendiment d'un RBM entrenat �s calcular la probabilitat del model i les probabilitats de realitzar mostres de dades de prova sota el RBM format. A m�s, la probabilitat de les mostres de dades aleat�ries tamb� es pot utilitzar com a mesura de la bondat del RBM.\\\\
A causa de la restricci� estructural, el resum expl�cit de les neurones ocultes (hidden) �s for�a senzill (vegeu l'equaci� (4.8)), per�, malauradament, la probabilitat d'una observaci� encara �s intractable a causa de la constant de normalitzaci�. La constant de normalitzaci� nom�s es pot computar exactament sumant exponencialment molts termes, i tret que la dimensi� del conjunt de dades sigui molt petita, �s senzillament impossible. Per tant, en lloc de computar-ho exactament, cal utilitzar un m�tode aproximat.\\\\
Per a l'estimaci� de la constant de normalitzaci�, aquesta tesi utilitza mostres d'import�ncia recomanada (Annealed importance sampling, AIS) que s'ha utilitzat amb �xit per calcular la constant de normalitzaci� del RBM \cite{salakhutdinov}.\\\\
L'AID es basa en un m�tode de mostreig d'import�ncia simple (SIS) que podria estimar la proporci� de dues constants de normalitzaci�. Per a dues densitats de probabilitat ${P_A (x) = \frac{P_A^*(x)}{Z_A}}$ i ${P_B (x) = \frac{P_B^*(x)}{Z_B}}$, la relaci� de dues constants de normalitzaci� ${Z_A}$ i ${Z_B}$ es pot estimar mitjan�ant un m�tode de mostreig de Monte Carlo sense cap biaix si �s possible provar de ${P_A (\cdot)}$:
\begin{equation}
\frac{Z_B}{Z_A} = E_{P_A} [\frac{P_B^*(x)}{P_A^*(x)}] \approx \frac{1}{M} \sum^M_{i=1} \frac{P_B^*(x_i)}{P_A^*(x_i)}
\end{equation}
on ${X_i}$ s�n mostres de ${P_A(X)}$. La qualitat de l'aproximaci� en termes de la vari�ncia dep�n molt de la proximitat de ${P_A( \cdot )}$ i ${P_B( \cdot )}$. Si ${P_A( \cdot )}$ no �s una aproximaci� gaireb� perfecte a PUB, llavors la vari�ncia de l'estimaci� pot ser tan gran com l'infinit. Basat en SIS, AIS calcula la constant de normalitzaci� de la distribuci� del model calculant la r�tio de les constants de normalitzaci� de distribucions intermedi�ries consecutives que van des de l'anomenada distribuci� b�sica i la distribuci� de destinaci�. \\\\
La distribuci� base es tria de tal manera que la seva constant normativa ${Z_0}$ es pot calcular exactament i �s possible recopilar mostres independents. Una selecci� natural de la distribuci� base per a un RBM �s un RBM amb zero pesos ${W}$. Aix� produeix la constant de normalitzaci�
\begin{equation}
Z_0 = \prod_i (1 + exp \{b_i\}) \prod_j (1 + exp \{c_j\})
\end{equation}
on els �ndexs ${i}$ i ${j}$ passen per totes les neurones visibles i ocultes, respectivament.\\\\
Mitjan�ant la computaci� del producte de les proporcions estimades de les constants de normalitzaci� interm�dia i ${Z_0}$, es pot estimar la constant de normalitzaci� del RBM objectiu. L'algoritme que implementa AIS es descriu en Algorisme 2.\\\\
L'algoritme presentat descriu la construcci� d'un RBM intermedis seguint el que va proposar Salakhutdinov \cite{salakhutdinov}. La distribuci� base est� representada per un RBM amb pesos nuls, per� els biaixos s�n id�ntics als del RBM objectiu. No obstant aix�, cal tenir en compte que hi ha altres possibilitats per construir distribucions interm�dies i triar una distribuci� b�sica. Per exemple, en els cap�tols seg�ents, la distribuci� base �s un RBM amb dos pesos zero i biaixos zero, de manera que no cal que cada RBM intermedi mantingui el doble de neurones ocultes que el RBM objectiu.
\begin{algorithm}
\caption{ Estimaci� de la normalitzaci� constant per mostreig d'import�ncia recomanada}
\begin{algorithmic} 
\STATE Crear una seq��ncia de temperatures ${T_k}$ tal que ${0 = T_0 < T_1 < \cdot \cdot \cdot < T_K = 1}$\\
Crear un RBM base, ${R_0}$ amb par�metres ${\theta_0 = (W_0,b,c)}$, on ${W_0 = 0}$ \\
Crear una seq��ncia de RBMs intermedis ${R_k}$ tal que
\begin{itemize}
\item T� el doble de nodes ocults que el RBM objectiu t�
\item Els seus par�metres s�n ${\theta_k = ([(1-T_k)W_0 T_k W],[(1-T_{k}) b_0 T_k b],[(1-T_k)c_{0}^{T} T_kc^T]^T)}$
\end{itemize}
\FOR{$m = 1 \cdot \cdot \cdot M$} 
\STATE {Obt� ${x_1}$ de ${R_0}$} 
\FOR{$k= 1 \cdot\cdot \cdot K-1$}
\STATE {Mostreja ${x_{k+1}}$ de ${R_k}$ mitjan�ant un mostreig de Gibbs d'un pas a partir de ${x_k}$.}
\ENDFOR \\
Estableix ${u_m = \prod_{k = 1}^K \frac{P_k^\ast (x_k)}{P_{k-1}^\ast (x_k)}}$, on ${P_k^\ast (\cdot)}$ �s una funci� de distribuci� marginal no normalitzada de ${R_k}$.
\ENDFOR \\
La estimaci� de ${\frac{Z_K}{Z_0}}$ �s ${\frac{1}{M} \sum_{m=1}^M u_m}$.
\end{algorithmic}
\end{algorithm}
\\\
Despr�s d'analitzar la primera forma ara ens centrarem en la precisi� de la classificaci� i altres mesures de la m�quina per a la seva avaluaci�.\\\\
�s evident que a partir dels treballs de recerca esmentats anteriorment utilitzant xarxes neurals profundes constru�des a partir de la pila del RBM, les probabilitats d'activaci� oculta del RBM entrenades en el conjunt de dades podrien millorar la precisi� de classificaci� en comparaci� amb classificar el conjunt de dades en funci� de les seves caracter�stiques brutes. Tanmateix, aquests enfocaments solen requerir l'afinaci� discriminativa que destrueix l'estructura generativa del RBM.\\\\
Afortunadament, els documents recents suggereixen que les probabilitats d'activaci� oculta de RBM que es van entrenar sense supervisi� tamb� ajuden a la tasca de classificaci�. Krizhevsky va utilitzar amb �xit un Gauss-Bernoulli RBM per extreure caracter�stiques d'imatges que ajuden a obtenir una alta precisi� de classificaci�. A m�s, es va demostrar que les formes m�s sofisticades de RBM introdu�des recentment \cite{ranzato} van poder extreure caracter�stiques que s�n m�s �tils per a la tasca de classificaci�.\\\\
A m�s, Coates et al. va mostrar que les caracter�stiques extretes pels models probabil�stics apreses d'una manera no supervisada superen les contraparts supervisades, com ara xarxes neuronals convolucionals i la xarxa de conviccions profundes .
Per tant, �s convenient utilitzar la precisi� de classificaci� del RBM format com a mesura de rendiment.\\\\
Addicionalment, gr�cies a la seva estructura bipartida i al mostreig de Gibbs capa�, l'error de reconstrucci� tamb� es pot utilitzar com a mesura per a l'avaluaci� del rendiment. Es defineix un error de reconstrucci�
\[\mathcal{E}(X) = \parallel x-x_1 \parallel_2\]
Tanmateix, aquestes mesures no reflecteixen directament la veritable qualitat del RBM, ja que l'entrenament no maximitza ni minimitza cap d'aquestes mesures. Per tant, per a la resta d'aquesta tesi, els experiments valoren principalment el RBM format per la probabilitat del model i les probabilitats de les mostres de prova donades el model.\\\\
Finalment nom�s ens queda analitzar la visualitzaci� directa i inspecci� de par�metres. Una manera d'analitzar la qualitat d'un model entrenat �s mirar les caracter�stiques (les ponderacions ${w_{ij}}$) i els termes de polaritzaci� ${c_j}$ corresponents a diferents neurones ocultes del RBM modelat. Especialment ajuda quan es formen mostres de dades consisteixen en imatges que es poden visualitzar f�cilment.\\\\
Per exemple, es poden visualitzar funcions del RBM formats en d�gits manuscrits. Cada caracter�stica o filtre s'assembla a una part de d�gits o una combinaci� de parts de d�gits. Quan l'aprenentatge falla, �s f�cil observar caracter�stiques degenerades que s�n sorolloses funcions globals.\\\\
En cas de biaixos ocults, els valors mateixos suggereixen si cada neurona oculta contribueix a la capacitat de modelitzaci� del RBM. Les neurones que tenen un gran biaix cj s�n la major part del temps actiu, i no s�n molt �tils, ja que els pesos associats a ells es poden incorporar al biaix b. D'altra banda, les neurones ocultes que s�n majorit�riament inactives (p.Ex., Amb grans biaixos negatius ${c_j}$) o les activacions dels quals s�n independents de les dades tamb� s�n in�tils, ja que la capacitat d'aprenentatge del RBM no canvia encara que s'eliminin.\\\\
Igual que altres mesures indirectes presentades anteriorment, la visualitzaci� i la inspecci� dels valors dels par�metres s'haurien de realitzar acuradament. No hi ha cap mesura objectiva per la qualitat de les funcions visualitzades, i les caracter�stiques visualitzades i els valors dels biaixos poden evolucionar lentament a trav�s de l'entrenament.\\\\
\subsubsection{Dificultats i solucions convencionals}
El fet que la funci� de destinaci� no es pugui calcular exactament durant l'aprenentatge dificulta l'entrenament dels RBM. �s computacional inviable de saber quan l'aprenentatge ha convergit, o fins i tot no �s f�cil dir si l'aprenentatge est� passant realment. A m�s, no �s possible utilitzar cap m�tode de degradat avan�at com el gradient de conjugat no lineal.\\\\
At�s que l'aprenentatge es realitza utilitzant actualitzacions de gradients estoc�stics, convergeix a una soluci� local.\\\\
El problema �s que no �s factible comparar les diferents solucions anal�ticament, i triar el millor d'entre elles. S'ha mostrat recentment que, depenent de la inicialitzaci� i els par�metres d'aprenentatge, els RBM resultants varien molt, fins i tot en els petits conjunts de dades de joguines.\\\\
M�s problem�ticament, els enfocaments m�s aproximats presentats en els apartats anteriors s'han demostrat que difereixen, si els par�metres d'aprenentatge no s'han triat de manera adequada. L'�s d'un millor m�tode de mostreig MCMC, p. Ex. el temperament paral�lel s'ha demostrat que evita millor el comportament divergent, per� a llarg termini sense utilitzar la programaci� de tarifes d'aprenentatge apropiada, la probabilitat del registre fluctua molt, cosa que no �s desitjable.\\\\
S'ha demostrat que un RBM �s un aproximador universal de manera que amb prou nombre de neurones ocultades pot modelar qualsevol distribuci� de probabilitat discreta.\\\\
Tanmateix, a la pr�ctica, el nombre de neurones ocultes sempre �s limitat i, depenent dels procediments d'aprenentatge, no totes les neurones ocultes contribueixen al poder de representaci� del RBM.\\\\
Per exemple, aquestes neurones ocultes sempre actives no tenen sentit, ja que els pesos associats a ells es poden incorporar a biaixos. A m�s, qualsevol neurona oculta inactiva sempre no t� sentit, des de llavors, l'eliminaci� de la neurona oculta no afecta la capacitat de modelatge del RBM.\\\\
Idealment, cada neurona oculta hauria de representar una caracter�stica "significativa" diferent, per exemple, una part t�pica de la imatge. Tanmateix, ens hem adonat que sovint les neurones ocultes tendeixen a aprendre caracter�stiques que s'assemblen al biaix visible b. Aquest efecte �s m�s destacat en la fase inicial d'aprenentatge i en el conjunt de dades en qu� els bits visibles s�n majorit�riament actius, com ara 1-MNIST on es va desplegar cada bit de conjunt de dades manuscrits MNIST.\\\\
Es va obtenir un RBM amb 36 neurones ocultes en 1-MNIST, que �s un conjunt de dades molt dens en comparaci� amb el MNIST original.
18 neurones ocultes no van poder aprendre cap caracter�stica �til, i s�n majorit�riament inactives.\\\\
Les altres 18 neurones s�n, en la seva majoria, actives i, tal com s'esperava, s'han apr�s unes caracter�stiques globals que s'assemblen una mica al biaix visible.\\\\
Fins i tot quan les dades de formaci� no s�n denses, amb la petita quantitat de neurones ocultades, l'elecci� inapropiada dels par�metres d'aprenentatge i l'elecci� inapropiada d'inicialitzaci� dels par�metres, moltes neurones ocultes seran in�tils. La visualitzaci� dels filtres apresos per un RBM amb 36 neurones ocultes entrenades a MNIST amb la taxa d'aprenentatge constant 0.1 i els pesos inicials mostrats de la distribuci� uniforme entre -1 i 1 s�n. No obstant aix�, encara existeixen aquestes neurones que s�n majorit�riament actives o majorit�riament inactives.
\subsection{Algorisme seleccionat a implementar en codi}
Un cop ja sabem quin algorisme hem d'utilitzar per tal de poder desenvolupar el nostre problema, ara hem de decidir com ser� implementat, �s a dir, si crearem nosaltres l'algorisme des de zero o utilitzarem alguna llibreria o algorisme ja conegut. \\\\
En aquest cas i despr�s de fer molta investigaci�, en primer lloc es va decidir utilitzar el llenguatge de programaci� Python per tal de desenvolupar les parts essencials de l'algorisme. Python ens ofereix una gran quantitat de recursos per al machine learning i actualment juntament amb Scala s�n els principals llenguatges utilitzats per al desenvolupament de m�quines.\\\
Aix� doncs un cop escollit el llenguatge ara falta decidir si implementar un RBM des de 0 o utilitzar alguna llibreria que ens permeti usar una implementaci� ja desenvolupada. \\\\
Crear una m�quina des de zero suposa un gran esfor� i treball i pot suposar que la m�quina no estigui ben dissenyada o que els algorismes aplicats i f�rmules siguin incorrectes. Aix� doncs es va decidir utilitzar una llibreria la qual ens permetia tenir un RBM ben creat i amb les caracter�stiques que busc�vem. La m�quina que es va decidir utilitzar seria de la llibreria \textit{sklearn} la qual ens proporcionaria una m�quina RBM anomenada \textit{BernoulliRBM}\cite{sklearnRBM}. \\\\
Aquesta m�quina es tracta d'una m�quina de Boltzmann Restrictiva amb unitats visibles bin�ries i unitats ocultes bin�ries. Els par�metres es calculen utilitzant la Probabilitat m�xima estoc�stica (SML), tamb� coneguda com Persistent Contrastive Divergence (PCD). La complexitat del temps d'aquesta implementaci� �s de ${O(d \ast \ast 2)}$ si assumim que el nombre de features �s igual al nombre de components.\\\\
A m�s aquesta implementaci� ens permet utilitzar diferents m�todes i funcions per tal d'obtenir resultats i/o entrenar la m�quina. Aquest s�n els m�todes i funcions principals d'aquesta implementaci�:
\begin{itemize}
\item ${fit (X[,y])}$: ens permet entrenar la m�quina a partir de les dades X.
\item ${fit\_transform (X[,y])}$: ens permet entrenar la m�quina a partir de les dades X i despr�s transformar-les.
\item ${get\_params([deep])}$: obtenim els par�metres del model que hem generat.
\item ${gibbs(v)}$: s'executa un mostreig de Gibbs.
\item ${partial\_fit(X[,y])}$: ens permet entrenar la m�quina a partir de les dades X que han de contenir una part segmentada de les dades.
\item ${score\_samples(X)}$: computaci� de la probabilitat de X.
\item ${set\_params(**params)}$: estableix els par�metres del model.
\item ${transform(X)}$: computaci� de les probabilitats d'activaci� de la capa oculta.
\end{itemize}
Un exemple del �s d'aquesta m�quina es troba en l'obtenci� de features per la classificaci� de d�gits. A continuaci� mostrarem un exemple de la creaci� d'un RBM utilitzant les funcions mencionades anteriorment.\\\
\begin{lstlisting}[language=Python,basicstyle=\footnotesize\ttfamily]
X = np.array([[0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 1, 1]])
model = BernoulliRBM(n_components=2)
model.fit(X)
#Sortida del resultat per la consola
BernoulliRBM(batch_size=10, learning_rate=0.1, 
n_components=2, n_iter=10, random_state=None,verbose=0)
\end{lstlisting}

Com podem observar creem una llista de diferents elements els quals tots aquests s�n binaris, ja que la m�quina nom�s pot rebre entrades bin�ries. A continuaci� creem la m�quina i li assignem el nombre de components i l'entrenem amb les dades d'entrada. A partir d'aqu� podr�em aplicar els altres m�todes per obtenir resultats o analitzar el seu funcionament.\\\
Com podem observar al crear la m�quina podem especificar-li alguns par�metres d'entrada. Aquests, definiran el seu comportament. Aquests par�metres s�n els seg�ents:
\begin{itemize}
\item \textit{n\_components}: Estableix el nombre de unitats bin�ries ocultes.
\item \textit{learning\_rate}: La velocitat d'aprenentatge de les actualitzacions de pes. Es recomana sintonitzar aquest hiperparametre. Els valors raonables es troben en el rang de 10 ** [0., -3.].
\item \textit{batch\_size}: Nombre d'exemples per minibatch.
\item \textit{n\_iter}: Nombre d'iteracions sobre el conjunt de dades de formaci� que es realitzar� durant la formaci�.
\item \textit{verbose}: El nivell de verbositat. El valor predeterminat, zero, significa el mode silenci�s.
\item \textit{random\_state}:Una inst�ncia de generador de n�meros aleatoris per definir l'estat del generador de permutacions aleat�ries. Si es d�na un enter, corregeix la llavor. Valors predeterminats del generador de nombres aleatoris global de \textit{numpy}.
\end{itemize}
Aquests par�metres no s�n obligatoris, es pot crear una m�quina sense la necessitat de definir tots els par�metres. En cas de no definir-ne cap, s'aplicaran els valors predeterminats.\\\\
Un cop tenim la implementaci� que usarem ara nom�s ens queda preparar les dades per la entrada a la m�quina. En els seg�ents apartats anirem explicant el desenvolupament de la m�quina creada sobre les dades que li proporcionem i el seu funcionament.
\newpage
\section{Desenvolupament de l'algoritme aplicat al problema}
Un cop ja tenim tots els elements que composen el nostre problema nom�s ens falta explicar el desenvolupament d'aquest utilitzant les dades que ens proporcionen i com utilitzem aquestes per a crear una m�quina i generar resultats. \\\
A continuaci� analitzarem les dades que rebem de l'aplicaci�, com es transformen per tal de ser aptes per la m�quina, com funciona i com definim la m�quina i com s�n les dades de sortida i com les transformem per tal de poder-les tornar a llegir amb l'aplicaci�.
\subsection{Esquema del model}
Tot seguit descriurem a alt nivell tots els passos pels quals passa una dada de entrada abans de arribar al model.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{diagram2}
\end{center}
\end{figure}
\begin{itemize}
\item ${E_1 =}$ Imatges col�locades a la graella.
\item ${E_2 = [id_1, id_2, \cdot \cdot \cdot, id_{48}]}$
\item ${E_3 = [[id_1^1,id_2^1,_id_3^1, ...,id_{255}^1], [id_1^2,id_2^2,_id_3^2, ...,id_{255}^2], ..., [id_1^{48},id_2^{48},_id_3^{48}, ...,id_{255}^{48}]]}$
\item ${E_4 = [[id_1^1, id_1^2,..., id_1^{48}],
[id_2^1, id_2^2,..., id_2^{48}],..., [0,0,...,id_y^{48}]}$
\item ${E_5 = [0_1,0_2, \cdot \cdot \cdot, 1_{10}, 0_{11}, \cdot \cdot \cdot, 0_{262}]}$
\item ${E_6 = [0_0,0_1, \cdot\cdot\cdot, 1_{125}, \cdot\cdot\cdot, 0_{12576}]}$
\item ${E_7 = [[id_1^1,id_2^1,_id_3^1, ...,id_{255}^1], [id_1^2,id_2^2,_id_3^2, ...,id_{255}^2], ..., [id_1^{48},id_2^{48},_id_3^{48}, ...,id_{255}^{48}]]}$
\item ${E_8 = [id_1, id_2, \cdot \cdot \cdot, id_{48}]}$
\end{itemize}
\subsection{Dades obtingudes de l'eina}
El primer pas com hem mencionat anteriorment �s la generaci� de moodboards a partir de l'eina creada. Les graelles resultants s�n imatges formades a partir d'altres imatges, s�n representacions visuals que en aquest cas no podem entrar directament a la m�quina ja que les hem de descompondre d'alguna manera per tal que les podem utilitzar per entrenar la nostra m�quina.\\\
Aix� doncs explicarem el format d'aquestes dades i quines dades hem obtingut en el nostre projecte.
\subsubsection{Format de les dades}
Com hem dit, cada imatge que forma un moodboard representa un objecte, en aquest cas un moble. Aix� doncs, cada moble ha de ser identificable d'alguna manera. La forma que tenim per identificar els mobles �s un ID que ens proporciona la base de dades per a cada un dels mobles disponibles que tenim, d'aquesta forma podem identificar els diferents mobles que composen una graella.\\\\
Aixo ens permet obtenir un diccionari o una llista dels diferents ID que formen un moodboard el qual podr� ser exportar d'una forma senzilla en un fitxer. Per tal d'obtenir aquesta llista nom�s necessitem rec�rrer el moodboard, comen�ant des de la primera cel�la, i obtenir els ID, que es troben internament en l'aplicaci�, d'aquells objectes col�locats En cas que no hi hagi cap objecte a la casella, posarem un 0 per tal d'indicar que all� no hi ha cap objecte posat. L'algorisme 3 ens mostra el procediment a seguir.
\begin{algorithm}
\caption{Generaci� de una llista de IDs a partir dels elements col�locats al moodboard.}
\begin{algorithmic} 
\STATE Crear una llista ${L}$ tal que ${L = [e_1, e_2, \cdot \cdot \cdot, e_{48}]}$ on ${e_x, x <= 48}$ correspon als ID dels objectes.\\\ Moodboard ${M}$ format per una llista de cel�les tal que ${M = [C_1,C_2, \cdot \cdot \cdot, C_{48}]}$.
\FOR{$i = 1 \cdot \cdot \cdot 48$} 
\STATE {Comprovar si la cel�la ${C_i}$ cont� una imatge} 
\IF {${C_i}$ t� una imatge}
\STATE Obtenir ${C_i (ID)}$ i afegir ${C_i (ID)}$ a la llista ${L}$
\ELSE
\STATE Afegir 0 a la llista ${L}$
\ENDIF
\ENDFOR \\
${L}$ cont� tots els ID del moodboard generat
\end{algorithmic}
\end{algorithm}
\\\\ Un cop apliquem l'algorisme descrit anteriorment, obtindrem una llista de ID, que abans eren simples imatges i no ens proporcionaven res d'informaci� a part de la visual. Ara tenim una llista amb els identificadors els quals cada un d'ells �s un objecte que s'ha col�locat al moodboard. Aix� doncs de moment hem passat d'una representaci� visual del objecte a una representaci� descriptiva formada per la llista dels identificadors dels objectes. \\\
A continuaci� es mostra un exemple d'un resultat obtingut:
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{id}
\caption{Exemple de la transformaci� de imatge a una llista de ID.}
\end{center}
\end{figure}
\\\
Aquest resultat per� no �s el definitiu per entrenar a la m�quina ja que aquests ID no ens donen informaci� sobre les caracter�stiques del objecte per tant necessitem realitzar una segona transformaci� per tal d'obtenir els ID que ens indicaran les caracter�stiques del color, material, forma... Aix� doncs hem de tornar-los a transformar per tal d'obtenir un diccionari amb totes les graelles plenes amb informaci� sobre els objectes. \\\\
Tal i com hem explicat, volem generar moodboards d'un estil concret per tant, cada estil es regeix per unes caracter�stiques que els objectes compleixen. Aix� doncs necessitem obtenir aquestes caracter�stiques per tal de poder entrenar correctament la m�quina.\\\\
Aquestes caracter�stiques les obtindrem de la base de dades i ens descriuran aspectes dels objectes. Com que no podem entrenar la m�quina utilitzant paraules haurem de convertir aquestes caracter�stiques en ID. Cada caracter�stica est� associada a un ID concret i cada objecte conte una llista de ID que es pot obtenir mitjan�ant crides a la base dades.
\\\ Aix� doncs necessitem aplicar una algorisme capa� d'obtenir un diccionari el qual contingui les cel�les del moodboard i cada una d'elles una llista de ID que s�n els que ens permetran identificar les caracter�stiques. Per tal d'aconseguir aquesta transformaci� farem servir l'algorisme 4.
\begin{algorithm}
\caption{Generaci� d'un diccionari amb les caracter�stiques dels objectes a partir de la llista de IDs.}
\begin{algorithmic} 
\STATE Crear un Diccionari ${D}$ tal que ${D = \{"style": [e_1, e_2, \cdot \cdot \cdot, e_{48}]\}}$ on ${e_x, x <= 48}$ correspon a les cel�les del moodboard i on ${e_x = [idc_1,idc_2, \cdot \cdot \cdot]}$.\\\ Llista ${L}$ cont� tots els ID obtinguts pr�viament del moodboard generat.
\FOR{$i = 1 \cdot \cdot \cdot 48$} 
\STATE {Obtenir llista ${C}$ de les caracter�stiques de l'element ${L_i}$ mitjan�ant crides a la base de dades \\
Llista temporal ${LL}$ contindr� els ID de les caracter�stiques per afegir-les al diccionari} 
\FOR{${j = 1 \cdot \cdot \cdot M = length(C)}$}
\STATE {Afegir ${C_j}$ a ${LL}$}
\ENDFOR
\\ Afegir ${LL}$ a ${D_i}$
\ENDFOR \\
${D}$ cont� una llista de totes els cel�les les qual cadascuna cont� una llista de ID de les caracter�stiques de cada objecte que es troba  al cel�la.
\end{algorithmic}
\end{algorithm}
\\\\Aplicant l'algorisme 4, obtindr�em un resultat similar de la Figura 16. Despr�s d'obtenir aquest diccionari el podem exportar per tal de tractar-lo m�s endavant ja que encara no podem passar aquestes dades a la m�quina. Ara de moment ja tenim la informaci� necess�ria, �s a dir, la informaci� que ens descriu cada objecte, una s�rie de n�meros que cada un correspon a una caracter�stica del objecte que es troba a la cel�la del moodboard.
\\\\
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{id_c}
\caption{Exemple de la transformaci� de ID a un diccionari de ID de les caracter�stiques de cada objecte.}
\end{center}
\end{figure}
\\\\
En aquest punt disposem d'un diccionari el qual ens permet saber a cada cel�la quines s�n les caracter�stiques del objecte que estava col�locat. Per� aquest no es el format definitiu, ja que tal i com es va explicar, la m�quina necessita una matriu com a dada d'entrada i en el nostre cas tenim un diccionari format per llistes que cada una cont� una llista com a element i que cada una t� una longitud diferent i la m�quina necessita que cada element de la matriu, encara que siguin llistes, tinguin la mateixa longitud. \\\\
El format ideal per a nosaltres seria el format que obtenim directament de l'eina per� no ens serveix perqu� no ens proporciona suficient informaci� per tant l'hem hagut de transformar per tal d'obtenir mes informaci� per� ara ja no tenim el format desitjat ja que tenim un diccionari en el qual tenim una llista i cada element una llista de les caracter�stiques dels objectes.\\\
Aix� doncs necessitem trobar una forma d'obtenir el format que desitgem, una llista on cada element contingui un identificador que correspondr� a un identificador d'una caracter�stica. \\\\
Una forma de resoldre aquest problema seria descomponent cada graella del diccionari en m�ltiples graelles que continguin un identificador per element. 
L'�nic problema a resoldre aqu� seria el cas del que les longituds s�n diferents ja que no tots els objectes tenen el mateix nombre de caracter�stiques. Aix� doncs hem de trobar una forma de solucionar aquest problema. \\\
La soluci� m�s senzilla i m�s r�pida d'aplicar �s buscar l'objecte amb m�s nombre de caracter�stiques. Un cop tenim aquest valor, aquest ens definir� el nombre de graelles a descompondre el diccionari, �s a dir, si suposem que l'objecte amb m�s caracter�stiques en t� 10, aix� vol dir que el m�xim nombre de graelles noves que hem de obtenir �s 10 per cada moodboard generat, ja que si en fem menys no hi hauran totes els caracter�stiques d'alguns objectes i perdrem informaci�.\\\\
Per tal d'obtenir aquest valor aplicarem un algorisme de cerca en tot el diccionari. Fins ara nom�s hem suposat que el diccionari nom�s cont� un moodboard per� en podem tenir varis, per tant, haurem de fer una recerca entre tots els elements del diccionari i anar guardant la longitud de cada cel�la fins a trobar la longitud m�xima. Per dur a terme aquest algorisme, primer transformarem el nostre diccionari en una llista ben constru�da. \\\
Per tal de realitzar la transformaci� utilitzarem un \textit{Dataframe} a partir del qual ens organitzar� els elements en forma de taula. D'aquesta taula agafarem les \textit{values}, que correspondran a cada cel�la i les afegirem a una llista aixi obtindrem una llista on cada element ser� una llista i aquesta tindr� com a elements les diferents caracter�stiques de cada objecte. 
\[input = [[id_1^1,id_2^1,_id_3^1, ...,id_{255}^1], [id_1^2,id_2^2,_id_3^2, ...,id_{255}^2], ..., [id_1^{48},id_2^{48},_id_3^{48}, ...,id_{255}^{48}]]\]
Un cop ja tenim la llista apunt nom�s necessitem aplicar la seg�ent funci�:
\begin{lstlisting}[language=Python,basicstyle=\footnotesize\ttfamily]
def getMaxLengthForElements(vector):
    maxLength = 0
    for i in range(len(vector)):
        tmp = vector[i]
        for j in range(len(tmp)):
            if (len(tmp[j]) > maxLength):
                maxLength = len(tmp[j])
    return maxLength
\end{lstlisting}
Aquesta funci� ens retornar� el numero m�xim de graelles que hem de generar de nou per tal d'obtenir a cada posici� de cada element un identificador diferent.\\\
Per a realitzar aquesta transformaci� hem de tenir en compte varis factors. El primer de tots hem de saber el nombre de moodboards que hem generat ja que haurem d'iterar sobre cada moodboard generat per transform-lo correctament. I el segon punt i el m�s important hem de tenir en compte com tractarem aquelles cel�les les quals, la seva longitud sigui menor que la longitud m�xima. En aquests casos la soluci� plantejada �s afegir un valor nul, �s a dir, un valor que no aporti informaci�, en aquest cas el valor 0. Aix� provocara que el resultat contingui llistes en les quals molts elements s�n 0 per� no ens importa ja que nom�s ens centrarem en els identificadors que no s�n 0. La funci� per obtenir aquesta transformaci� �s la seg�ent:
\begin{lstlisting}[language=Python,basicstyle=\footnotesize\ttfamily]
def transformInputVector(vector, maxLength, length):
    output = []
    for i in range(length):
        v = vector[i]
        for j in range(maxLength):
            tmp = []
            length_v = len(v)
            for k in range(length_v):
                if j >= len(v[k]):
                    tmp.append(0)
                else:
                    tmp.append(v[k][j])
            output.append(tmp)
    return output
\end{lstlisting}
Com podem observar nom�s necessitem passar-li el vector \textit{input} descrit anteriorment i obtindrem un vector \textit{outuput} que tindr� el seg�ent format:
\[output = [[id_1^1, id_1^2,..., id_1^{48}],
[id_2^1, id_2^2,..., id_2^{48}],..., [0,0,...,id_y^{48}]\]
Un exemple d'una graella generada a partir de la descomposici� en v�ries graelles de les dades d'entrada podria ser la seg�ent:
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{id_s}
\caption{Exemple d'una de les graelles obtingudes al realitzar la descomposici�.}
\end{center}
\end{figure}
\\\ El n�mero de llistes que obtindr�em com aquestes seria igual a la longitud m�xima que hem obtingut multiplicat pel nombre de moodboards que hem generat. D'aquesta forma, realitzant tot el proc�s obtindr�em el format correcte de les nostres dades per tal d'entrenar la m�quina.
\\\\Resumint, l'objectiu de la primera part del tractament de les dades �s convertir les imatges obtingudes a identificadors que ens permetin classificar els objectes segons les seves caracter�stiques. Per tal d'aconseguir aix� primer hem de transformar aquestes imatges, en aquest cas utilitzant l'eina i la base de dades, en una llista de identificador. El seg�ent pas �s a partir d'aquests identificadors obtenir un diccionari on cada element estigui format per una llista, que seran les 48 cel�les del moodboard, on cada element contingui una llista de tots els identificadors de les caracter�stiques del objecte que es trobava a la cel�la i aix� obtenir un format de dades m�s prec�s i descriptiu. I l'�ltim pas a realitzar �s descompondre aquest diccionari en llistes, de forma que obtinguem que cada element de cada llista sigui un identificador d'una caracter�stica d'un objecte, �s a dir, descompondre cada moodboard en tantes llistes, com sigui necessari fins a obtenir un identificador a cada element.
\subsubsection{Dades obtingudes del projecte}
Ara que ja sabem com �s el format de les nostre dades explicarem quines s�n les dades que hem obtingut al utilitzar l'eina durant el proc�s de desenvolupament del projecte.\\\
En primer lloc es va demanar als experts la creaci� d'alguns moodboards d'un estil concret. En aquest cas l'estil s'anomenava Popular Modern. Es van crear 8 moodboards totalment diferents.\\\\
Utilitzant l'eina es va obtenir un fitxer on hi havia els 8 moodboards transformats a llistes de identificadors. Seguidament com hem explicat anteriorment i aplicant els algorismes descrits es van obtenir els identificadors de les caracter�stiques dels objectes i es va crear un diccionari el qual cada element era un moodboard format de llistes de identificadors de les caracter�stiques de cada element. En aquest punt es va buscar la llargada m�xima de caracter�stiques que va resultar ser 15. Aix� doncs sortirien 120 graelles noves ja que per cada moodboard, aquest es descompondria en 15 graelles on cada element, contindria un identificador. \\\\
Finalment, les dades resultants obtingudes despr�s d'aplicar la primer transformaci�, estan formades per una matriu de mida 120 per 48 on cada element �s una llista, una graella, amb un identificador d'una caracter�stica a cada posici�. En aquest cas, les dades proporcionades eren poques ja que amb 120 elements no �s possible entrenar una m�quina.\\\\
Per solucionar aquest problema vam decidir duplicar algunes dades ja que en realitat era com generar un moodboard igual a un altre. Aplicar aix�, podria afectar als resultats ja que les dades duplicades poden afectar al comportament de la m�quina per� en aquest cas com que les dades eren insuficients es va d'haver aplicar aquesta soluci�. L'altre soluci� era demanar als experts que generessin 500 moodboards per� per falta de temps i coordinaci� no va ser possible. Aix� doncs necessit�vem obtenir una mida de dades m�s gran que 5000, per tant, vam duplicar les dades 51 vegades i vam obtenir una matriu de mida 6120 per 48. Pod�em haver escollit un altre valor, per� es va creure correcte tenir aquest volum de dades. Ara ja ten�em una mida raonable per entrenar una m�quina i pod�em procedir a realitzar els seg�ents passos.
\subsection{Dades d'entrament}
Cada m�quina necessita un format especific per tal de llegir correctament les dades i poder aprendre d'elles per tant necessitem transformar les dades actuals en dades llestes per la ingesta. A continuaci� explicarem com s�n aquestes dades i quines dades hem obtingut.
\subsubsection{Format de les dades}
Un cop ja tenim les dades d'entrada transformades necessitem comprovar que la m�quina que crearem �s capa� de llegir-les. En el nostre cas crearem un RBM i segons la descripci� que hem explicat anteriorment, el format de les nostres dades �s el correcte per� com que utilitzarem una implementaci� d'una llibreria, aquesta m�quina t� una s�rie de restriccions sobre les dades d'entrenament per a la m�quina. \\\
La m�s important �s que les dades han de ser bin�ries, �s a dir, cada element, cada ID ha de estar en forma de llista de binaris. Tot i que el format de les nostres dades podria funcionar en altres m�quines que utilitzen el mateix algorisme, en el nostre cas necessitem transformar-les per tal que la nostra implementaci� funcioni correctament. En aquest punt, les dades de les quals disposem no es troben en aquest format per tant necessitem trobar alguna forma de convertir-les.\\\\
Les dades que tenim son dades categ�riques, �s a dir, s�n variables que contenen valors d'etiqueta, a cada caracter�stica li assignem un n�mero. Aix� doncs, una soluci� al problema seria codificar cada un dels ID que tenim en binari per� aquesta soluci� no seria optima ja que haur�em de fer una m�quina que pogu�s descodificar cada un d'ells per tal de poder entendre el valor que li estem entrant i incl�s en alguns casos no podr�em entrar certes dades si el n�mero a codificar fos molt llarg.\\\\
La soluci� m�s �ptima i m�s assequible �s utilitzar els denominats \textit{One Hot Vectors}. Aquests tipus de vectors s�n un grup de bits entre els quals les combinacions v�lides de valors s�n nom�s aquelles amb un sol bit alt(1) i tots els altres valors amb bits baixos(0). �s a dir, ens permet codificar qualsevol n�mero en forma d'una llista que ser� tant llarga com el n�mero m�s alt i que contindr� tots els valors 0 excepte la posici� en la qual representi el valor a codificar.\\\\
Un exemple f�cil per a veure el funcionament d'aquests vectors �s aplicar al nostre cas. Disposem de 262 caracter�stiques diferents a la nostre base de dades per tant si volem codificar un identificador d'una caracter�stica concreta, per exemple l'identificador 10, el codificarem de la seg�ent manera:
\[10 = [0_1,0_2, \cdot \cdot \cdot, 1_{10}, 0_{11}, \cdot \cdot \cdot, 0_{262}]\]
D'aquesta forma podrem codificar tots els identificadors de forma bin�ria. Per transforma cada identificador podem crear un algorisme que ens converteixi un n�mero en un vector o tamb� podem utilitzar eines que ens proporcionen algunes llibreries com �s el cas de la llibreria \textit{sklearn} que ens proporciona un codificador per codificar les nostres dades. Aquest codificador s'anomena \textit{OneHotEncoder}\cite{sklearnOnehotencoder}. \\\\
Aquest codificador ens permet transformar les nostres dades d'entrada en una matriu, on cada columna correspon a un possible valor d'una caracter�stica. Al crear un codificador d'aquest tipus podem establir alguns par�metres d'entrada per tal de definir com ser� i com seran les dades que li entrem i com s�n les que volem obtenir.\\\\
De tots els par�metres que podem definir els m�s importants s�n:
\begin{itemize}
\item ${n\_values}$: Nombre de valors per caracter�stica. En aquest cas el nombre de identificadors m�xims que hi pot haver. Com hem dit anteriorment, aquest valor �s 262. 
\item ${sparse}$: Boolea que ens indica si utilitzarem matrius disperses, \textit{sparse matrix}, o matrius denses i el format del resultat.
\end{itemize}
A part d'aquests par�metres tamb� t� m�todes que ens permetran realitzar certes accions. El m�todes m�s importants i que m�s endavant utilitzarem s�n els seg�ents:
\begin{itemize}
\item ${fit (X[,y])}$: ens permet entrenar el codificador amb les dades X.
\item ${fit\_transform (X[,y])}$: ens permet entrenar el codificador a partir de les dades X i despr�s transformar-les.
\item ${transform(X)}$: ens permet transformar unes dades X en un one hot vector.
\end{itemize}
Aix� doncs, un cop creat el codificador i entrenat amb les dades que hem obtingut de la primera transformaci� podem obtenir les nostres dades llestes per la ingesta de la m�quina. La creaci� d'aquestes dades provocar� que la mida de les dades augmenti sobretot en les files de la matriu, en aquest cas, en la llista d'elements de cada cel�la ja que cada cel�la contindr� una successi� de 0 i 1 i aquesta ser� tant llarga com el nombre de valors per caracter�stica que li haguem definit.
\subsubsection{Creaci� del codificador i dades obtingudes}
Ara ja sabem qu� necessitem per transformar les nostres dades per realitzar la ingesta a la m�quina i aix� entrenar-la. A continuaci� explicarem com hem creat el nostre codificador, quins par�metres hem definit i quines s�n les dades obtingudes.\\\\
Recordem que de la primera transformaci� de les dades vam obtenir una matriu de mida 6120 per 48 que contenia les graelles amb els identificadors de les caracter�stiques dels objectes del moodboard. El primer que hem de definir �s el nombre de valors per caracter�stica, en aquest cas disposem de 262 caracter�stiques diferents, el que �s el mateix, que 262 identificadors diferents per tant, el par�metre \textit{n\_values} ser� igual a 262. \\\\
La segona cosa i la que m�s ens afectar� alhora del rendiment del codificador �s el boole� \textit{sparse}. Com hem dit aquest valor ens indica quin tipus de matriu farem servir i obtindrem, si ser� una \textit{sparse matrix} o una matriu densa. Per entendre b� la decisi� a prendre necessitem saber les diferencies entre els dos tipus. \\\\
Les \textit{sparse matrix} nom�s emmagatzemen les entrades que no s�n zero, aquelles entrades de la matriu que tenen algun valor mentre que les denses emmagatzemen tots els valors. Aix� doncs la difer�ncia es troba alhora de treballar amb elles, �s a dir, a l'hora de rec�rrer les matrius o de comprimir-les. En aquests cas �s molt millor treballar amb \textit{sparse matrix} ja que el proc�s ser� m�s r�pid i sobretot quan es tracten de matrius molt grans. En cas contrari, si es tracten de matrius petites es poden utilitzar matriu denses. \\\\
Aplicant aix� al nostre cas podem fer servir les dos formes ja que la matriu �s gran per� no exageradament enorme. De tot formes a continuaci� mostrarem dos exemples, Figura 18, de la creaci� del nostre codificador i el resultat que dona, un utilitzant \textit{sparse matrix} i l'altre utilitzant matrius denses.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{onehotencoder}
\caption{Creaci� del codificador de les dos forma. A dalt amb matrius denses i a baix amb \textit{sparse matrix}}
\end{center}
\end{figure}
Com podem observar, el resultat final �s una matriu del mateix nombre de files que la matriu anterior per� ara els elements s�n m�s grans ja que multipliquem cada element per 262. Tamb� podem podem observar que utilitzant \textit{sparse matrix} el temps es redueix. En aquest cas el temps �s molt petit per� es pot observar una difer�ncia. Aix� doncs el millor m�tode �s fer servir \textit{sparse matrix}. \\\\
El contingut de la nostre matriu ser� per a cada fila una successi� de 0 i 1, al tractar-se d'una \textit{sparse matrix} si la mostrem per pantalla nom�s veurem aquelles posicions que contenen un valor diferent a 0.
Ara ja tenim les dades llestes per entrar a la m�quina i entrenar-la per� primer de tot hem de crear-la d'acord a les dades que tenim.
\subsection{Creaci� i entrenament del RBM}
Un cop ja tenim les dades transformades per l'entrenament de la m�quina nom�s ens queda crear la m�quina i entrenar-la per tal d'obtenir resultats. A continuaci� explicarem la creaci� de la nostra m�quina i analitzarem el seu comportament.
\subsubsection{Creaci� del RBM a partir de les dades}
En apartats anterior hem vist com crear un RBM est�ndard utilitzant la llibreria. Per� ara ja tenim les dades i necessitem trobar els par�metres adients per tal que la creaci� d'aquesta m�quina sigui la correcte o la m�s adient per al nostre problema. \\\
Els principals camps que definirem seran el \textit{n\_components}, \textit{learning\_rate} i \textit{n\_iter}.\\\\
Per comen�ar hem de definir el nombre de unitats ocultes que tindr� la nostra m�quina. Hi ha v�ries formes de trobar el n�mero perfecte de unitats ocultes aplicant formules per� en el nostre cas hem decidit que aquest nombre ser� el valor total de les caracter�stiques disponibles que en aquest cas es 262, aix� disposem d'una unitat oculta per a cada un dels valors de les dades. \\\\
Un cop ja tenim el nombre de components decidit hem de decidir la velocitat d'aprenentatge. Tal i com es va explicar anteriorment ha d'estar en el rang de 10**[0., -3.], aix� doncs a partir de la documentaci� de la llibreria \cite{sklearnRBM} i partir d'alguns exemples que tamb� es trobaven a la documentaci� vam poder establir un valor relativament correcte per a la nostre m�quina.\\\\
 Es va establir un valor de 0.01. Aquest valor �s una funci� que el que defineix �s com de r�pid canvien el pesos dels valors al llarg del aprenentatge. Si aquest valor �s massa alt, �s possible que es perdi el punt 0 del pendent i si es massa baix pot provocar que es tardi molt a arribar aquest punt.\\\\
 Finalment queda definir el nombre d'iteracions. Ja es sap que en una m�quina d'aquest tipus, cada iteraci� pot durar molt de temps per tant no vol�em que tardes molt a realitzar totes les iteracions. En un principi vam establir unes 10 iteracions per tal de comprovar el temps i la seva efici�ncia. Finalment, a partir dels resultats es va establir un valor de 20 iteracions.\\\\
 Aix� doncs, un cop ja tenim tots els valors definits nom�s ens queda crear la m�quina. A continuaci�, a la figura 19 es mostra com s'ha realitzat la creaci� de la m�quina.
 \begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{rbm}
\caption{Creaci� del RBM amb els par�metres definits anteriorment}
\end{center}
\end{figure}
\subsubsection{Entrenament del RBM}
Un cop ja creada la m�quina necessitem entrenar-la per tal de, m�s endavant, poder generar noves dades i aix� poder analitzar el seu funcionament amb les dades que li passem. Per tal d'entrenar-la nom�s cal cridar el m�tode \textit{fit} de la m�quina.\\\
Al cridar aquest m�tode li hem de passar les dades les quals volem que siguin les utilitzades per l'entrenament. En aquest cas li hem de passar la \textit{sparse matrix} que hem obtingut anteriorment. \\\\
A mesura que es vagin realitzant les iteracions es mostrar� per pantalla la iteraci� la qual s'acaba de realitzar, la \textit{pseudo-likelihood} i el temps que ha tardat. La \textit{pseudo-likelihood} �s una estimaci� bastant decent sobre el rendiment del model actual encaixant les dades de formaci�. Com m�s baix sigui, millor. Aix� doncs al entrenar la nostra m�quina creada obtenim un resultat com aquest:
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{rbmtrain}
\caption{Resultat del entrenament de la m�quina}
\end{center}
\end{figure}
\\\\
Com podem observar el temps de cada iteraci� es similar i la \textit{pseudo-likelihood} va variant a mesura que passen les iteracions. Aquesta informaci� ens permet analitzar el comportament de la nostra m�quina, �s a dir, si volem canviar el valor la \textit{pseudo-likelihood} per tal que sigui m�s baix i millor necessitem anar realitzant proves i anar canviar els diferents par�metres de la m�quina. En aquest cas, una soluci� seria canviar el \textit{batch\_size} per� aix� comportaria m�s temps per iteraci� i a m�s tenint en compte que el nombre de dades actual �s baix en comparaci� a altres m�quina no es factible canviar aquest valor. \\\\
La q�esti� final �s fer proves fins a trobar una implementaci� que ens sigui assequible, que s'adapti a les nostres necessitats i a les del problema proposat. Per tal de trobar aquesta implementaci� es van realitzar diferents proves amb diferents valors per� els valors de temps eren molt elevats i la \textit{pseudo-likelihood} era molt alta en comparaci� a les altres implementacions.\\\\
Finalment un cop acaben totes les iteracions ja tenim la m�quina creada per tal d'obtenir valors nous. Per tal d'evitar entrenar la m�quina cada cop que volem generar valors nous es va decidir guardar tant les dades d'entrenament com la m�quina en un format de fitxer \textit{pickle}. Aquest format ens permet guardar la nostra m�quina i les nostres dades sense la necessitat d'ocupar molt d'espai i tamb� ens permet m�s endavant carregar de nou la m�quina, ja entrenada, les nostres dades i els par�metres tant de la m�quina com del codificador.
\subsection{Dades de sortida}
Despr�s d'haver entrenat la m�quina nom�s ens queda una pas i �s generar moodboards. Per� per tal de generar moodboards hem de saber com obtenir valors nous a partir de la m�quina i en quin format es troben i quin format necessitem per visualitzar-los a la eina.
\subsubsection{Dades obtingudes del RBM}
Un cop la m�quina est� entrenada necessitem generar dades noves. Per tal de generar dades noves, la llibreria amb la qual hem implementat la m�quina ens proporciona un m�tode per tal de generar aquestes dades. Aquest m�tode es tracte del mostreig de Gibbs, \textit{gibbs(v)}. El mostreig de Gibbs �s un algoritme per generar una mostra aleat�ria a partir de la distribuci� de probabilitat conjunta de dues o m�s variables aleat�ries. A partir d'un vector de unitats visibles, de valors visibles i v�lids genera un altre vector d'unitats visibles mitjan�ant el mostreig de Gibbs.\\\\
Aix� doncs, aquesta funci� ha de rebre com a par�metre un \textit{one hot vector}. En aquest cas, aquest vector ha de correspondre a una dada de les d'entrenament ja que s�n les aquestes s�n les �niques dades v�lides. En molts casos, es t� unes dades d'entrenament i unes dades de test, per� en aquest cas al tenir poques dades no s'ha dividit en dos tipus de dades.\\\
D'aquesta forma, al passar un vector format de 0 i 1 a la funci� \textit{gibbs}, aquesta ens retornar� un vector de unitats visibles de la m�quina.\\\\
Aquest vector que obtindrem no estar� format per 0 i 1 sin� que estar� format per booleans a cada posici�. A m�s la seva llargada no ser� de 48 elements com la mida d'un moodboard sin� que la mida ser� de 12576 com la mida de cada vector de la matriu d'entrada a la m�quina. Aix� doncs el format d'aquest vector resultant ser�:
\[ [False_0,False_1, \cdot\cdot\cdot, True_{125}, \cdot\cdot\cdot, False_{12576}]\]
Aix� ens suposa alguns problemes ja que nosaltres volem un vector que tingui una mida de 48 i on a cada posici� tingui un o m�s d'un identificador de caracter�stiques. El primer problema a observar �s que haurem de transformar el vector obtingut per obtenir identificador i el segon problema �s que a si nom�s obtenim un vector nom�s tindrem un identificador per cel�la o poder cap. Per tant haurem de realitzar el mostreig de Gibbs varis cops fins que tinguem un vector correcte.\\\\
Primer de tot hem de transformar el vector per obtenir un vector de 0 i 1. Per fer aixo nom�s hem de rec�rrer el vector i substituir tots els valors \textit{False} per 0 i els valors \textit{True} per 1.\\\
Un cop realitzat aquest proc�s ja tenim un vector amb el seg�ent format:
\[ [0_0,0_1, \cdot\cdot\cdot, 1_{125}, \cdot\cdot\cdot, 0_{12576}]\]
El seg�ent pas �s convertir aquest vector en un de mida 48 i amb identificadors a cada posici� on cada identificador pot tenir un valor entre 1 i 262 que s�n els identificador de les caracter�stiques que tenim. Tamb� poden tenir un valor 0 el qual ens indica que en aquella posici� no hi ha cap objecte. Per realitzar aquesta transformaci� aplicarem el seg�ent algorisme:
\begin{algorithm}
\caption{Generaci� d'un vector amb identificadors a cada posici� a partir d'un vector de 0 i 1}
\begin{algorithmic} 
\STATE Vector ${V}$ tal que ${V = [i_0,i_1, \cdot \cdot \cdot, i_{48}]}$ on ${ 0 <= i <= 262}$. \\\ 
Vector ${D}$ tal que ${D = [j_0,j_1, \cdot \cdot \cdot, i_{12576}]}$ on ${ j = 0 o j = 1}$.
\FOR{$i = 1 \cdot \cdot \cdot 48$} 
\STATE Obtenir el vector ${K}$ tal que ${K = D[(262 * i):((i + 1) * 262)]}$
\IF{${K}$ no cont� 1}
\STATE Afegir 0 a ${V}$
\ELSE 
\STATE Afegir ${K.index(1)}$ a ${V}$
\ENDIF
\ENDFOR \\
${V}$ cont� a cada posici� un \textit{int} que �s l'identificador d'una caracter�stica d'un objecte.
\end{algorithmic}
\end{algorithm} \\\
Aix� doncs, aplicant l'algorisme anterior obtindr�em un vector amb els identificadors corresponents a les caracter�stiques. Per�, tot i aix� encara ens falta solucionar el problema d'obtenir m�s d'un valor per cada element. Per tal d'aconseguir el format final correcte necessitem tenir m�s d'un identificador a cada element, �s a dir, una llista de identificadors a cada posici� tal i com obten�em les dades despr�s de transformar-les al sortir de l'eina.\\\\
Per aconseguir aquest format necessitem generar diferents vectors utilitzant el mostreig de gibbs, �s a dir, utilitzant les dades d'entrenament aleat�ries i realitzar un mostreig de gibbs d'aquestes. Per realitzar aix� nom�s cal que definim un nombre fixe de iteracions, en aquest cas, vam definir 50 ja que no era un nombre molt elevat ni molt baix. Aplicant el mostreig de Gibbs durant 50 iteracions aconseguim un vector que cont� 50 elements on cada un d'ells �s un vector de 0 i 1 i que utilitzant l'algorisme 5 els transformarem a un vector de identificadors.\\\\
Finalment nom�s hem d'ajuntar els vectors que hem obtingut de l'algorisme 5 i obtindrem el vector final amb un format com el seg�ent:
\[final\_data = [[id_1^1,id_2^1,_id_3^1, ...,id_{255}^1], [id_1^2,id_2^2,_id_3^2, ...,id_{255}^2], ..., [id_1^{48},id_2^{48},_id_3^{48}, ...,id_{255}^{48}]]\]
Un exemple d'aquest vector amb dades reals obtingudes a partir de la m�quina creada podria ser el que es mostra a la figura 21.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{finaldata}
\caption{Resultat final de la transformaci�}
\end{center}
\end{figure}
\\\\
A la figura 21, podem observar que la mida del vector �s de 48 elements i cadascun ells cont� una llista d'identificadors de caracter�stiques. Hem aconseguit passar d'un vector de mida 12576, format per valors booleans a un vector de mida 48 el qual esta format pels identificadors de les caracter�stiques dels objectes que m�s endavant es col�locaran en el moodboard. Finalment l'�ltim pas que queda �s com passem d'aquest vector a una representaci� visual, a un moodboard format per objectes.
\subsubsection{Creaci� de moodboards a partir de les dades}
Aquest �s la part final per obtenir un moodboard completament generat a partir de les dades obtingudes de la m�quina. En aquest punt tenim un vector que cont� els identificadors de les caracter�stiques dels objectes que podrien anar a cada cel�la, ja que tenim 48 elements que corresponen a les cel�les del moodboard. \\\\
Aix� doncs l'objectiu ara �s a partir d'aquests identificadors obtenir els objectes que compleixin aquestes caracter�stiques. Per tal d'obtenir aquests objectes necessitarem fer v�ries peticions a la base de dades. Com es va explicar en l'apartat del disseny de l'eina cada cel�la t� unes subcategories que defineixen un rang d'objectes que s'hi poden col�locar. El primer que hem de fer �s llegir el fitxer que cont� per a cada cel�la els identificadors de subcategories i guardar-los en un vector el qual tindr� 48 elements i a cada element una llista de identificadors.\\\\
Ara disposem de dos vectors del mateixa mida i amb llistes d'identificadors que signifiquen diferents coses per� que serveixen pel mateix, per establir un rang d'objectes a col�locar a les cel�les. Per tal, d'aconseguir aquests rangs hem de rec�rrer els dos vectors simult�niament i fer crides a base de dades de forma que aquestes crides en serveixin per establir un filtre a la base de dades. Aquest filtre estar� format per les subcategories de la cel�les i s'hi ajuntara els identificadors de les caracter�stiques del vector obtingut anteriorment de forma que la uni� donar� com a resultat un rang d'objectes.\\\\
D'aquesta forma a cada crida que fem a la base de dades, se'ns retornar un rang de identificadors corresponents a objectes que compleixen les condicions de pert�nyer a una o m�s subcategories i que tenen certes caracter�stiques. En cas que se'ns retorni una llista de identificadors molt extensa, com que no tenim forma de saber quin objecte �s millor que un l'altre, agafarem un identificador aleatori ja que si es troba a la llista �s que compleix totes les condicions.\\\\
Finalment, si apliquem aquest procediment a tots els elements del vector obtindrem un vector final semblant a aquest:
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{final_vector}
\end{center}
\end{figure}
\\
Aquest vector ja ens defineix el moodboard obtingut despr�s de totes les transformacions. Per tant, ara per visualitzar aquest moodboard nom�s l'hem de guardar en un fitxer i amb l'eina utilitzar la funci� de visualitzar moodboards ja creats per tal de visualitzar correctament el moodboard obtingut de la m�quina.
\newpage
\section{Resultats i conclusions i l�nies de continuaci�}
Ara ja tenim totes les parts enlla�ades i preparades per generar moodboards, l'ultim pas que ens queda �s obtenir resultats, avaluar-los, treure'n conclusions i explicar les possibles l�nies de continuaci�  que existeixen per aquest projecte que hem desenvolupat.
\subsection{Qualitat de les graelles generades}
Avaluar models generatius com la m�quina que em creat �s molt complicat ja que no tenim un resultat est�ndard per avaluar el resultat obtingut i no qualsevol persona pot detectar si aquell resultat �s bo o dolent. Aix� doncs la nostra forma d'avaluar els nostres resultats ser� utilitzant l'ajuda d'un expert per a valorar els moodboards obtinguts. \\\\
L'avaluaci� que definirem per avaluar els moodboards generats ser� una avaluaci� qualitativa. Es generaran 10 moodboards utilitzant la m�quina i al eina respectivament i se'ls ensenyaran al expert i haur� de valorar per cada un d'ells quins s�n els objectes que fallen i perqu�. �s important emfatitzar que degut a dificultats t�cniques sols dispos�vem de 8 dades d'entrenament.\\\\
D'aquesta forma obtindrem els moodboards m�s ben generats i els que m�s objectes incorrectes tenen. Aquesta avaluaci� ens permetr� tenir una primera idea si la m�quina esta generant els moodboards correctament, �s a dir, si cont� objectes correctes i si �s el cas, dels que s'han generat quina �s la mitja de elements correctes.\\\\
Tamb� ens permetr� saber les causes dels objectes que han fallat i aix� intentar millorar la m�quina per tal que tals objectes no siguin generats o que valori uns m�s que els altres. A continuaci� es mostren els moodboard generats.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{merge}
\caption{Resultat de la generaci� de 10 moodboards.}
\end{center}
\end{figure}
\\\\
Com podem observar tots els moodboards segueixen un esquema similar, les caselles on no hi ha objectes sempre solen ser les mateix. Tamb� cal observar que hi ha objectes que no tenen imatges, aix� pot complicar l'avaluaci� ja que no sabem com �s l'objecte col�locat. En aquest punt vam decidir que suposar�em que l'objecte era correcte ja que en cas de suposar el contrari el moodboard ja seria incorrecte. Una millora de l'algorisme seria evitar els objectes que no tenen imatge.\\\\
Aix� doncs el seg�ent pas �s donar aquests moodboards al expert i que ens digui quins objectes fallen a cada un i perqu� fallen. Una vegada l'expert ha avaluat el resultat obtenim la imatge de la figura 25. L'expert ha marcat els objectes que estan malament i les observacions que ha fet sobre aquests.
\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{avaluation}
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{avaluation1}
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{avaluation2}
\caption{Resultat de l'avaluaci� del expert moodboards generats.}
\end{center}
\end{figure}
\\\\
Com podem observar de les 10 imatges que s'han generat la majoria tenen algun element incorrecte o que no s'adequa al estil. L'expert a part de dir quins s�n els que estan malament tamb� ens indica algunes de les raons per les quals aquests objectes s�n incorrectes o no s'adeq�en a l'estil. \\\\
En aquest cas les imatges corresponen a l'estil de \textit{Popular Modern}, �s a dir, popular modern. Aix� doncs, molts dels objectes que s'han col�locat no segueix aquest estil, aquesta l�nia de popular modern. La majoria s�n popular tradicional o tradicionals purament per tant, la col�locaci� d'aquests no es correcte a dins la imatge. \\\\
Si analitzem la quantitat d'elements de tots els moodboards tenim que en els deu moodboards tenim un total de de 191 objectes col�locats, que serien una mitjana de 19 objectes per moodboard aix� doncs podem saber el tant per cent d'objectes correctes i incorrectes que hi ha. Aix� doncs tenim que el 35\% dels objectes col�locats s�n incorrectes. A partir d'aix� podem dir que encara que tots els moodboards hagin marcats com a incorrectes, m�s de la meitat dels objectes col�locats s�n correctes amb l'estil seleccionat. Aix� ens indica que el funcionament de la m�quina �s correcte tot i que no del tot, no �s perfecte, perqu� si funcion�s perfectament haur�em de tenir un percentatge casi nul d'elements incorrectes.
\subsubsection{Possibles problemes}
\begin{itemize}
\item Les dades d'entrada s�n escasses. Nom�s ten�em 8 graelles generades correctament i tot i que amb les transformacions hem aconseguit augmentar el nombre de graelles i duplicant dades no s�n suficients ja que per a qualsevol problema d'aquest estil necessitem una mida de dades molt gran i amb dades no duplicades. Les dades que ten�em per aconseguir els resultats ens han frenat, ens han provocat, que els resultats no fossin del tot correctes ni que fossin com esper�vem. L'obtenci� de poques dades tamb� es causada a conseq��ncia alienes al projecte, relacionades amb l'empresa i la gesti� de projectes.
\item El filtratge de les dades de sortida �s incorrecte. Quan obtenim les dades de sortida de la m�quina i les transformem per obtenir els identificadors de les caracter�stiques, seguidament realitzem crides a la base de dades per obtenir els identificadors dels objectes. Aquestes crides es fan unint els diferents identificadors utilitzant un operador \textit{AND} per� la base de dades ho interpreta com una suma, \textit{OR}, aix� doncs ens retorna una llista d'objectes bastant  m�s extensa del que ens esper�vem i per tant hem d'agafar un objecte aleatori. Si el funcionament fos el correcte ens retornaria una llista d'objectes per� en aquest cas seria molt petita, de dos o tres objectes que compleixen totes les condicions.
\item Els colors no concorden. La m�quina no t� en compte la relaci� de colors entre objectes, no estableix cap relaci� entre els objectes que es col�loquen ja que nom�s s'analitzen les caracter�stiques d'aquests. Aix� doncs �s normal que els colors dels objectes no tinguin relaci� quan en la generaci� pr�via de moodboards l'expert col�locava els objectes per tal de tenir coher�ncia entre ells per� alhora d'entrenar la m�quina aquesta relaci� no s'analitza profundament.
\end{itemize}
\newpage
\subsection{Conclusions}
Amb el desenvolupament d'aquest projecte hem apr�s que la realitzaci� d'una tasca manual, repetitiva i costosa de temps, com �s la generaci� de moodboards, es pot millorar aplicant t�cniques de Inteligencia Artificial.\\\\
Tamb� hem apr�s com dissenyar una aplicaci� en unity que dona una interf�cie gr�fica per tal de poder fer m�s f�cil la tasca de la generaci� de moodboards als dissenyadors. \\\\
La part m�s important ha sigut crear la m�quina amb capacitat d'aprenentatge ja que hem hagut de aprendre el funcionament b�sic del machine learning per tal de decidir quin tipus de m�quina era millor pel problema descrit. La creaci� de la m�quina ens ha perm�s establir un sistema d'aprenentatge per tal de generar moodboards a partir dels creats anteriorment i ens ha perm�s automatitzar tota la tasca per tal d'evitar que els dissenyadors comencin a treballar des de una moodboard buida.\\\\
Els resultats que hem obtingut despr�s de realitzar totes les proves que hem cregut necess�ries no han tingut la qualitat esperada. Tot i aix�, les resultats ens han perm�s  donar una eina que pot servir per a donar idees de moodboards inicials als dissenyadors. 
\\\\
�s important remarcar que la qualitat dels resultats  pot ser deguda a la falta de entrenament que dispos�vem. Per aquest projecte no hem pogut disposar de m�s dades per culpa de la falta de temps dels dissenyadors de la empresa que no ens van proporcionar un nombre de moodboards  gaire elevat. En conseq��ncia  l'entrenament de la m�quina s'ha fet amb tant sols 8  dades (graelles) que s�n moltes menys de les que es fan servir per a projectes de aprenentatge autom�tic. \\\\
Tot i aix�, hem pogut desenvolupar correctament un sistema d'aprenentatge per a la realitzaci� d'unes tasques especifiques i hem pogut comprovar, encara que els resultats no fossin els ideals, que el funcionament era acceptable.  S'ha intentat que la mem�ria plasmi la metodologia seguida i no es centri �nicament en els resultats que estan lluny de poder substituir a interioristes per a generar moodboards. \\\ Per altra banda, aquests resultats ens permeten  que la persona nom�s hagi de canviar poc elements per tal de crear un moodboard correcte, i aix� tractar aquests moodboards generats com una base inicial per a la generaci� de nous.\\\\
Finalment, durant la realitzaci� del projecte han anat apareixent problemes que han provocat canvis importants en la implementaci� de la m�quina i s'han anat canviat especificacions que afectaven a les dades.  Finalment s'han  definit uns est�ndards  per tal de poder fer funcionar correctament la m�quina i obtenir resultats (encara que no fossin els ideals) per tal de poder comprovar que s'havia realitzat la implementaci� correctament.\\\\
Per acabar, el projecte ha suposat un repte tant per el seu desenvolupament com per la seva avaluaci� ja que en un principi es desconeixia com s'avaluaria el problema presentat ja que mai havia tractat un tema com aquest ni havia desenvolupat cap m�quina d'aquest estil. A m�s la empresa no tenia cap idea clara de com avaluaria el projecte i reptant �s dif�cil decidir si s'ha obtingut un resultat suficientment bo com per posar-ho en producci�.\\\\ El projecte m'ha perm�s aprendre molt sobre el machine learning i la seva utilitzaci�. Tamb� m'ha for�at a aprendre noves eines vitals per a la implementaci� eficient del model, com la llibreria numpy i scipy que han sigut importants per a poder codificar les dades com a matrius sparse i poder entrenar el model de manera eficient.
\newpage
\subsection{Treball futur: Com millorar el projecte}
Un cop s'ha acabat aquest projecte podem millorar-lo i seguir-lo desenvolupant de v�ries maneres. En primer lloc i el seg�ent pas que s'hauria de fer per a continuar el projecte seria que un cop generats els moodboards s'editessin per tal de corregir els objectes que s�n incorrectes i aix� obtenir nous moodboards per entrenar la m�quina. D'aquesta forma s'obtindria un volum m�s elevat de dades que beneficiaria a la m�quina ja que l'entrenament seria molt m�s correcte i les dades d'entrada m�s extenses.\\\\
Una altra opci� seria generar les m�quines per a diferents estils, ja que en aquest projecte nom�s l'hem creat per un estil concret i poder seria interessant tenir tantes m�quina com estils per tal de generar qualsevol estil de moodboard que es desitgi. \\\\
Una altra millora que es podria aplicar seria la de crear un RBM nou que a part de llegir els objectes tamb� relacion�s els objectes col�locats, �s a dir, que establir normes mitjan�ant una xarxa neuronal per tal d'obtenir resultats m�s correctes. Tamb� �s podria realitzar una ingesta per les imatges, �s a dir, passar com a input les imatges en comptes de la informaci� dels objectes i aix� obtenir directament imatges de la sortida de la m�quina. Una altra opci� seria passar com a input la imatge i la graella per tal que l'aprenentatge tingues en compte les dues fonts d'informaci� i pogu�s avaluar millor les normes que s'estableixen..  \\\\
Finalment una de les �ltimes millores que es podrien aplicar al projecte seria que tot estigu�s incl�s en l'aplicaci�, �s a dir, que l'aplicaci� tingu�s ja implementades les m�quines i que des de l'aplicaci� poguessin aprendre directament i generar els moodboards i mostrar-los. Aix� permetria un control sobre la visualitzaci� dels moodboards i sobre les dades d'entrenament ja que en tot moment es visualitzarien els objectes que es col�loquen i/o es generen.
\normalfont

\newpage

\begin{thebibliography}{25}
\bibitem{1} A Beginner\textsc{\char13}s Tutorial for Restricted Boltzmann Machines,  \newline \texttt{https://deeplearning4j.org/restrictedboltzmannmachine}.

\bibitem{2} Eric Yuan; Restricted Boltzmann Machine,  \newline \texttt{http://eric-yuan.me/rbm/}, 2014.

\bibitem{3} Restricted Boltzmann Machines (RBM),  \newline \texttt{http://deeplearning.net/tutorial/rbm.html}.

\bibitem{4} Geoffrey Hinton; Advanced Machine Learning, Lecture 4, Restricted Boltzmann Machines,  \newline \texttt{https://www.cs.toronto.edu/~hinton/csc2535/notes/lec4new.pdf}.

\bibitem{sklearnRBM} Documentation RBM sklearn,  \newline \texttt{http://scikit-learn.org/stable/modules/generated/sklearn.neural\_network.BernoulliRBM.html}.

\bibitem{sklearnOnehotencoder} Documentation OneHotEncoder sklearn,  \newline \texttt{http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html}.

\bibitem{salakhutdinov}Salakhutdinov, R. Learning Deep Generative Models. \newline \texttt{https://www.cs.cmu.edu/~rsalakhu/papers/annrev.pdf}.

\bibitem{leroux} Representational power of restricted Boltzmann machines and
deep belief networks \newline \texttt{http://www.iro.umontreal.ca/~lisa/publications2/index.php/attachments/single/22}

\bibitem{carreira} Carreira-Perpi��n, M. A. and Hinton, G. E. On Contrastive Divergence Learning \newline \texttt{http://www.cs.toronto.edu/~fritz/absps/cdmiguel.pdf}

\bibitem{ranzato} Ranzato, M., Krizhevsky, A., and Hinton, G. E. \newline \texttt{http://www.cs.toronto.edu/~fritz/absps/ranzato\_aistats2010.pdf}
\end{thebibliography}
\end{document} 

